(function (global, factory) {
	if (typeof define === "function" && define.amd) {
		define(['lodash', 'sinon', '../src/index.js', '../test-kit/testDrivers/index', '../test-kit', 'chai', '../test-kit/test'], factory);
	} else if (typeof exports !== "undefined") {
		factory(require('lodash'), require('sinon'), require('../src/index.js'), require('../test-kit/testDrivers/index'), require('../test-kit'), require('chai'), require('../test-kit/test'));
	} else {
		var mod = {
			exports: {}
		};
		factory(global.lodash, global.sinon, global.index, global.index, global.testKit, global.chai, global.test);
		global.index = mod.exports;
	}
})(this, function (_lodash, _sinon, _index, _index2, _testKit, _chai) {
	'use strict';

	var _ = _interopRequireWildcard(_lodash);

	var _sinon2 = _interopRequireDefault(_sinon);

	var escalate = _interopRequireWildcard(_index);

	var _testKit2 = _interopRequireDefault(_testKit);

	var _chai2 = _interopRequireDefault(_chai);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : {
			default: obj
		};
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};

			if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}

			newObj.default = obj;
			return newObj;
		}
	}

	/**
  * Created by amira on 2/8/15.
  */
	var expect = _chai2.default.expect;
	_chai2.default.use(_testKit2.default.chai);

	var EXPECTED_LEVELS = ['debug', 'info', 'warn', 'error', 'fatal'];
	var PARAMS = ['TEST PARAMS', 1, {}];

	describe('escalate', function () {
		var sandbox, originalConfig;
		after(function () {
			sandbox.restore();
		});
		before('save original configuration', function () {
			originalConfig = escalate.config();
			sandbox = _sinon2.default.sandbox.create();
		});
		afterEach('reset configurations', function () {
			escalate.config(originalConfig);
		});
		EXPECTED_LEVELS.forEach(function (level) {
			it(level + ' is a legal report level', function () {
				expect(escalate.levels).to.contain(level);
			});
		});
		describe('default configuration', function () {
			before('spy on console', function () {
				['info', 'warn', 'error'].forEach(function (level) {
					sandbox.spy(console, level);
				});
			});
			it('logger threshold is info', function () {
				expect(originalConfig.logThresholdStrategy()).to.eql('info');
			});
			it('panic threshold is error', function () {
				expect(originalConfig.panicThresholdStrategy()).to.eql('error');
			});
			it('panic throws', function () {
				expect(function () {
					return originalConfig.panicStrategy().apply(undefined, PARAMS);
				}, 'reporting fatal with default configuration').to.throw;
			});
			var checkStackTrace = function checkStackTrace(thrower) {
				var stack1 = new Error('hi').stack.split('\n');
				var stack2;
				try {
					thrower(escalate.getMailBox());
				} catch (e) {
					stack2 = e.stack.split('\n');
				}
				var shorterStack = _.min([stack1.length, stack2.length]) - 1;
				for (var i = 1; i < shorterStack; ++i) {
					expect(stack1[i].split(/\s+/)[2], 'line ' + i).to.equal(stack2[i + 1].split(/\s+/)[2]); // ['','at','Context.<anonymous>','(dist/test/index.js:79:43)']
				}
			};
			it('.fatal() stack trace starts in same place as regular throws (transparent stack trace)', function () {
				checkStackTrace(function (mailBox) {
					return mailBox.fatal('hi');
				});
			});
			it('.post("fatal") stack trace starts in same place as regular throws (transparent stack trace)', function () {
				checkStackTrace(function (mailBox) {
					return mailBox.post('fatal', 'hi');
				});
			});
			['debug', 'info', 'warn', 'error'].forEach(function (level) {
				var consoleLevel = level === 'debug' ? 'info' : level;
				it('logger.' + level + ' writes to console.' + consoleLevel, function () {
					var _originalConfig$logge;

					console[consoleLevel].reset();
					(_originalConfig$logge = originalConfig.loggerStrategy())[level].apply(_originalConfig$logge, PARAMS);
					expect(console[consoleLevel].called, 'logger called').to.be.true;
					expect(console[consoleLevel].args, 'arguments of logger call').to.eql([PARAMS]);
				});
			});
		});
		describe('.config()', function () {
			beforeEach('reset configurations', function () {
				escalate.config(originalConfig);
			});
			it('returns updated configuration', function () {
				var comparisonBase = escalate.config();
				var func = _.constant('warn');
				var newConfig = escalate.config({ logThresholdStrategy: func });
				comparisonBase.logThresholdStrategy = func;
				expect(comparisonBase).to.eql(newConfig);
			});
			it('returns detached configuration', function () {
				escalate.config().loggerStrategy = null;
				expect(escalate.config(), 'current config').to.eql(originalConfig);
			});
			it('accepts partial configuration', function () {
				escalate.config({ loggerStrategy: originalConfig.loggerStrategy });
				escalate.config({ panicStrategy: originalConfig.panicStrategy });
				escalate.config({ logThresholdStrategy: originalConfig.logThresholdStrategy });
				escalate.config({ panicThresholdStrategy: originalConfig.panicThresholdStrategy });
			});
			it('affects pre-existing mailboxes', function () {
				var mailBox = escalate.getMailBox();
				var panicSpy = sandbox.spy();
				escalate.config({ panicStrategy: _.constant(panicSpy) });
				expect(function () {
					return mailBox.fatal.apply(mailBox, PARAMS);
				}, 'reporting fatal after overriding panic').not.to.throw();
				expect(panicSpy.calledOnce, 'panicSpy called once').to.be.true;
				expect(panicSpy.calledWithExactly.apply(panicSpy, PARAMS), 'panicSpy called with expected args').to.be.true;
			});
		});
		describe('mailbox', function () {
			var mailBox, logger, panic;
			function replaceAllButEscalate(field, replacement) {
				var config = {};
				config[field] = function (ctx) {
					return ctx === 'escalate' ? originalConfig[field](ctx) : replacement;
				};
				escalate.config(config);
			}
			beforeEach('init per test', function () {
				logger = {};
				panic = sandbox.spy();
				mailBox = escalate.getMailBox('some context');
				replaceAllButEscalate('loggerStrategy', logger);
				replaceAllButEscalate('panicStrategy', panic);
			});

			EXPECTED_LEVELS.forEach(function (panicLevel, panicLevelIdx) {
				describe('with panic threshold ' + panicLevel, function () {
					beforeEach('reset log level to avoid it being higher than panic level', function () {
						replaceAllButEscalate('logThresholdStrategy', 'debug');
					});
					beforeEach('panic threshold ' + panicLevel, function () {
						replaceAllButEscalate('panicThresholdStrategy', panicLevel);
					});
					EXPECTED_LEVELS.slice(0, panicLevelIdx + 1).forEach(function (logLevel, logLevelIdx) {
						describe('and log threshold ' + logLevel, function () {
							beforeEach('log threshold ' + logLevel, function () {
								replaceAllButEscalate('logThresholdStrategy', logLevel);
							});
							EXPECTED_LEVELS.forEach(function (reportLevel, reportLevelIdx) {
								function levelTestSuite(reportFn) {
									return function () {
										beforeEach('spy on logger.' + reportLevel + ' and report', function () {
											logger[reportLevel] = sandbox.spy();
											reportFn();
										});
										if (reportLevelIdx >= panicLevelIdx || reportLevelIdx < logLevelIdx) {
											it('logger.' + reportLevel + ' is not called', function () {
												expect(logger[reportLevel].called, 'logger called').to.be.false;
											});
										} else {
											it('logger.' + reportLevel + ' is called', function () {
												expect(logger[reportLevel].args, 'logger called exactly once with the expected arguments').to.eql([PARAMS]);
											});
										}
										if (reportLevelIdx < panicLevelIdx) {
											it('panic is not called', function () {
												expect(panic.called, 'panic called').to.be.false;
											});
										} else {
											it('panic is called', function () {
												expect(panic.args, 'panic called exactly once with the expected arguments').to.eql([PARAMS]);
											});
										}
									};
								}
								describe('.' + reportLevel + ' method', levelTestSuite(function () {
									var _mailBox;

									return (_mailBox = mailBox)[reportLevel].apply(_mailBox, PARAMS);
								}));
								describe('.post(\'' + reportLevel + '\',...) method', levelTestSuite(function () {
									var _mailBox2;

									return (_mailBox2 = mailBox).post.apply(_mailBox2, [reportLevel].concat(PARAMS));
								}));
								describe('.' + reportLevel + 'Check method', function () {
									it('returns ' + (reportLevelIdx >= logLevelIdx), function () {
										expect(mailBox[reportLevel + 'Check']()).to.equal(reportLevelIdx >= logLevelIdx);
									});
								});
								describe('.levelCheck(\'' + reportLevel + '\', ...) method', function () {
									it('returns ' + (reportLevelIdx >= logLevelIdx), function () {
										expect(mailBox.levelCheck(reportLevel)).to.equal(reportLevelIdx >= logLevelIdx);
									});
								});
							});
						});
					});
				});
			});
			describe('timers', function () {

				it('should log info with time duration', function () {
					var clock = sandbox.useFakeTimers();
					escalate.config(originalConfig);
					var infoSpy = sandbox.spy();
					escalate.config({
						activateTimers: true,
						loggerStrategy: function loggerStrategy(context) {
							return {
								info: infoSpy,
								warn: function warn() {},
								error: function error() {},
								log: function log() {}
							};
						}
					});
					var myMailBox = escalate.getMailBox('new context');
					myMailBox.startTimer('a');
					clock.tick(5);

					myMailBox.endTimer('a');
					expect(infoSpy.args).to.be.eql([['timer a took 5', 'timer', 'a', 5]]);
				});

				it('should not log timers when activateTimers config is false', function () {
					var clock = sandbox.useFakeTimers();
					escalate.config(originalConfig);
					var infoSpy = sandbox.spy();
					escalate.config({
						activateTimers: false,
						loggerStrategy: function loggerStrategy(context) {
							return {
								info: infoSpy,
								warn: function warn() {},
								error: function error() {},
								log: function log() {}
							};
						}
					});
					mailBox.startTimer('a');
					clock.tick(5);

					mailBox.endTimer('a');
					expect(infoSpy.args).to.be.eql([]);
				});
			});
		});
	});
});
//# sourceMappingURL=index.js.map