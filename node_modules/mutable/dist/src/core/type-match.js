"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var escalate_1 = require("escalate");
var validation_1 = require("./validation");
var lifecycle_1 = require("./lifecycle");
var any_1 = require("./../data-types/any");
var types_1 = require("../types");
var MAILBOX = escalate_1.getMailBox('mutable.type-match');
function validateAndWrap(itemValue, type, lifeCycle, errorContext, errorTemplate) {
    itemValue = matchValueToType(itemValue, type).wrap(itemValue, type, errorContext, errorTemplate);
    lifecycle_1.optionalSetManager(itemValue, lifeCycle);
    return itemValue;
}
exports.validateAndWrap = validateAndWrap;
/**
 * checks if one instance matches another instance's type and schema values
 * (not-symetric)
 * @param origin first instance to match, also defines the data schema
 * @param other other instance to match
 * @return true iff all other is assignable to origin's type and matches all it's fields
 */
function isDataMatching(origin, other) {
    return !!(origin === other || (origin && !other) ||
        (_.isString(origin) && _.isString(other) && origin.localeCompare(other) === 0) ||
        (_.isObject(origin) && origin.constructor && origin.constructor && validation_1.validateNotNullValue(origin.constructor, other) &&
            Object.keys(origin.constructor._spec).every(function (fieldName) { return isDataMatching(origin[fieldName], other[fieldName]); })));
}
exports.isDataMatching = isDataMatching;
var TypeMatch = (function () {
    function TypeMatch(value, errorContext, errorTemplate) {
        this.value = value;
        this.errorContext = errorContext;
        this.errorTemplate = errorTemplate;
        this.match = matchTypes.MISMATCH;
        this.type = any_1.Any;
        this.errorDetails = {
            path: errorContext ? errorContext.path : '',
            expected: any_1.Any,
            actual: this.value
        };
        // TODO: search for _type annotation and create match with global type registry
    }
    TypeMatch.prototype.wrap = function () {
        return this.match.wrap(this.value, this.type, this.errorContext, this.errorTemplate, this.errorDetails);
    };
    TypeMatch.prototype.byReference = function (provider, path) {
        var match, type;
        if (types_1.isNonPrimitiveType(this.type)) {
            return this.match.byReference(provider, path, this.value, this.type, this.errorContext, this.errorTemplate, this.errorDetails);
        }
        else {
            return this.value;
        }
    };
    TypeMatch.prototype.tryTypes = function () {
        var newTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newTypes[_i] = arguments[_i];
        }
        for (var i = 0; i < newTypes.length && !this.match.best; ++i) {
            this.tryType(newTypes[i]);
        }
        return this;
    };
    TypeMatch.prototype.tryType = function (newType) {
        var errorDetails = {
            path: this.errorContext ? this.errorContext.path : '',
            expected: newType,
            actual: this.value
        };
        var newMatch = matchValueToType(this.value, newType, errorDetails);
        if (this.match.worseThan(newMatch)) {
            this.match = newMatch;
            this.type = newType;
            this.errorDetails = errorDetails;
        }
        return this;
    };
    return TypeMatch;
}());
exports.TypeMatch = TypeMatch;
/**
 * each match type knows how to wrap input value,
 * can tell if it's better than another match type,
 * and can also tell if it's the best possible match for a given input
 */
var matchTypes = {
    PERFECT: {
        wrap: function (itemValue) { return itemValue; },
        byReference: function (provider, path, itemValue) {
            return itemValue;
        },
        worseThan: function (o) { return false; },
        best: true
    },
    NATIVE_JS_VALUE: {
        wrap: function (itemValue, type, errorContext) {
            return type.create(itemValue, undefined, errorContext);
        },
        byReference: function (provider, path, itemValue, type) {
            return type.byReference(provider, path);
        },
        worseThan: function (o) { return o === matchTypes.PERFECT; }
    },
    MISMATCH: {
        wrap: function (itemValue, type, errorContext, errorTemplate, errorDetails) {
            var errorPath = null;
            if (errorDetails) {
                itemValue = errorDetails.actual;
                type = errorDetails.expected;
                errorPath = errorDetails.path;
            }
            MAILBOX.post(errorContext.level, validation_1.misMatchMessage(errorContext, type, itemValue, errorPath, errorTemplate));
            return type.create();
        },
        byReference: function (provider, path, itemValue, type, errorContext, errorTemplate, errorDetails) {
            if (errorTemplate === void 0) { errorTemplate = 'reference'; }
            var errorPath = null;
            if (errorDetails) {
                itemValue = errorDetails.actual;
                type = errorDetails.expected;
                errorPath = errorDetails.path;
            }
            MAILBOX.post(errorContext.level, validation_1.misMatchMessage(errorContext, type, itemValue, errorPath, errorTemplate));
            return type.create();
        },
        worseThan: function (o) { return true; }
    }
};
function matchValueToType(itemValue, type, errorDetails) {
    if (itemValue === null && type.isNullable()) {
        return matchTypes.PERFECT;
    }
    else if (itemValue === null) {
        return matchTypes.MISMATCH;
    }
    else if (type.validateType(itemValue)) {
        return matchTypes.PERFECT;
    }
    else if (type.allowPlainVal(itemValue, errorDetails)) {
        return matchTypes.NATIVE_JS_VALUE;
    }
    else {
        return matchTypes.MISMATCH;
    }
}
//# sourceMappingURL=type-match.js.map