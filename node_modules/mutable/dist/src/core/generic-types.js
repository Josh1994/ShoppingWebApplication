"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var escalate_1 = require("escalate");
var validation_1 = require("./validation");
var union_1 = require("./../data-types/union");
var MAILBOX = escalate_1.getMailBox('mutable.genericTypes');
/**
 * try to match a type to a value
 * @param subTypes either a type or a collection of types
 * @param instance null, mutable or plain value instance to match
 * @returns {*} type if matched, otherwise undefined
 */
function getMatchingType(subTypes, val) {
    return doOnType(subTypes, function (type) {
        return (typeof type.validateType === 'function' && type.validateType(val)) ||
            (typeof type.allowPlainVal === 'function' && type.allowPlainVal(val))
            ? type : undefined;
    });
}
exports.getMatchingType = getMatchingType;
/**
 * do an action on the generic type and return the result.
 * if the generic type represents a union, do the action on each type in the union and return the first result that is not undefined
 */
function doOnType(subTypes, action) {
    if (subTypes) {
        if (subTypes.id === 'Union') {
            subTypes = subTypes.getTypes();
        }
        if (typeof subTypes === 'function') {
            return action(subTypes, 0);
        }
        else {
            for (var key in subTypes) {
                var type = subTypes.hasOwnProperty(key) && subTypes[key];
                if (typeof type === 'function') {
                    var result = action(type, key);
                    if (result !== undefined) {
                        return result;
                    }
                }
            }
        }
    }
}
exports.doOnType = doOnType;
function mapOrOne(funcOrArr, iteratorFunc) {
    if (_.isFunction(funcOrArr) || _.isPlainObject(funcOrArr)) {
        return iteratorFunc(funcOrArr, 0);
    }
    else {
        return _.map(funcOrArr, iteratorFunc);
    }
}
function reportDefinitionErrors(subTypes, reportFieldError, template) {
    if (_.isPlainObject(subTypes)) {
        //prevalidated
        return null;
    }
    var subtypes = mapOrOne(subTypes, function (subtype) { return (subtype && subtype.id) || 'subtype'; });
    return doOnType(subTypes, function (type, index) {
        var error = reportFieldError(type, template);
        if (error) {
            var path;
            if (_.isArray(subtypes)) {
                var withArrow = subtypes.slice();
                withArrow[index] = validation_1.arrow + withArrow[index];
                path = withArrow.join('|');
            }
            else {
                path = validation_1.arrow + subtypes;
            }
            return {
                message: error.message,
                path: path
            };
        }
    });
}
exports.reportDefinitionErrors = reportDefinitionErrors;
/**
 * @param subTypesArgs one or many subtypes objects (a propper result of normalizeTypes())
 * @returns {string} string representation using angular notation
 */
function toString() {
    var subTypesArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        subTypesArgs[_i] = arguments[_i];
    }
    return '<' +
        subTypesArgs.map(toUnwrappedString).join(', ') +
        '>';
}
exports.toString = toString;
function toUnwrappedString(subTypes) {
    return (typeof subTypes === 'function' && subTypes.id) || (subTypes && Object.keys(subTypes).join('|'));
}
exports.toUnwrappedString = toUnwrappedString;
function unnormalizedArraytoUnwrappedString(subTypes) {
    return (typeof subTypes === 'function' && (subTypes.id || 'subtype')) || (subTypes && _.forEach(subTypes, unnormalizedArraytoUnwrappedString));
}
exports.unnormalizedArraytoUnwrappedString = unnormalizedArraytoUnwrappedString;
/**
 *
 * @param subTypes could be a type, a result of a call to either() or a result of a previous call to this function
 * @returns {*} a type, or an object that maps type ids to types (a union type object)
 */
function typesAsArray(subTypes) {
    if (subTypes && subTypes.id === 'Union') {
        subTypes = subTypes.getTypes();
    }
    return subTypes;
}
exports.typesAsArray = typesAsArray;
/**
 * method for union types creation
 * @param types types to unionize
 * @returns {*} the union of the supplied types
 */
function either() {
    var types = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        types[_i] = arguments[_i];
    }
    return union_1.default.of(types);
}
exports.either = either;
//# sourceMappingURL=generic-types.js.map