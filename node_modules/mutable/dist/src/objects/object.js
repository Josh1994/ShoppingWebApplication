"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var base_1 = require("../core/base");
var escalate_1 = require("escalate");
var utils_1 = require("../utils");
var validation_1 = require("../core/validation");
var type_match_1 = require("../core/type-match");
var lifecycle_1 = require("../core/lifecycle");
var default_object_1 = require("./default-object");
var mobx_1 = require("mobx");
var config_1 = require("../config");
var MAILBOX = escalate_1.getMailBox('mutable.MuObject');
function getClass(inst) {
    return inst.constructor;
}
var FakeObjectAdministrator = (function () {
    function FakeObjectAdministrator(name) {
        this.name = name;
        this.atoms = {};
    }
    return FakeObjectAdministrator;
}());
FakeObjectAdministrator.prototype["isMobXObservableObjectAdministration"] = true;
var MuObject = (function (_super) {
    __extends(MuObject, _super);
    function MuObject(value, options, errorContext) {
        var _this = _super.call(this, value, options, errorContext) || this;
        errorContext = errorContext || _this.__ctor__.createErrorContext('Type constructor error', 'error');
        if (MuObject === utils_1.getPrimeType(_this.__ctor__)) {
            MAILBOX.post(errorContext.level, errorContext.entryPoint + ": \"" + errorContext.path + "\" Instantiating the base type is not allowed. You should extend it instead.");
        }
        else if (MuObject.uniqueId === utils_1.getPrimeType(_this.__ctor__).uniqueId) {
            MAILBOX.post(errorContext.level, errorContext.entryPoint + ": \"" + errorContext.path + "\" \"" + _this.__ctor__.name + "\" is not inherited correctly. Did you remember to import core3-runtime?");
        }
        _this.$mobx = getClass(_this).makeAdmin(_this.getName());
        if (mobx_1.extras.isSpyEnabled()) {
            _.forEach(getClass(_this)._spec, function (fieldValue, fieldName) {
                mobx_1.extras.spyReportStart({
                    type: "add",
                    object: _this,
                    name: fieldName,
                    newValue: _this[fieldName]
                });
                mobx_1.extras.spyReportEnd();
            });
        }
        return _this;
    }
    MuObject.cloneValue = function (value) {
        if (!_.isObject(value)) {
            return {};
        }
        return _.reduce(this._spec, function (cloneObj, fieldSpec, fieldId) {
            cloneObj[fieldId] = fieldSpec.cloneValue(value[fieldId]);
            return cloneObj;
        }, {});
    };
    MuObject.defaults = function (circularFlags) {
        if (circularFlags === void 0) { circularFlags = ''; }
        var spec = this._spec;
        var circularFlagsNextLevel = (circularFlags ? circularFlags : ';') + this.uniqueId + ';';
        //var args = arguments;
        var isCircular = ~circularFlags.indexOf(';' + this.uniqueId + ';');
        if (isCircular) {
            if (!this.options || !this.options.nullable) {
                MAILBOX.warn('DEFAULT CIRCULAR DATA! resolving value as null - please add better error/warning');
            }
            return null;
        }
        else {
            return Object.keys(this._spec).reduce(function (val, key) {
                var fieldSpec = spec[key];
                val[key] = fieldSpec.defaults.call(fieldSpec, circularFlagsNextLevel);
                return val;
            }, {});
        }
    };
    MuObject.getFieldsSpec = function () {
        return _.clone(this._spec);
    };
    MuObject.validate = function (value) {
        var _this = this;
        return validation_1.validateNullValue(this, value) ||
            _super.validate.call(this, value) && !!(value && Object.keys(this._spec).every(function (key) { return _this._spec[key].validate(value[key]); }));
    };
    MuObject.allowPlainVal = function (value, errorDetails) {
        var _this = this;
        if (validation_1.validateNullValue(this, value)) {
            return true;
        }
        else if (_.isPlainObject(value)) {
            // todo: instead of (value._type === this.id) use global types registry and isAssignableFrom()
            if (value._type && value._type !== this.id) {
                if (errorDetails) {
                    errorDetails.expected = this;
                    errorDetails.actual = value;
                }
                return false;
            }
            return Object.keys(this._spec).every(function (fieldName) {
                if (value[fieldName] === undefined || _this._spec[fieldName].validateType(value[fieldName])) {
                    return true;
                }
                else {
                    var fieldErrorDetails = errorDetails && _.defaults({ path: errorDetails.path + "." + fieldName }, errorDetails);
                    var result = _this._spec[fieldName].allowPlainVal(value[fieldName], fieldErrorDetails);
                    if (errorDetails && !result) {
                        _.assign(errorDetails, fieldErrorDetails);
                        return false;
                    }
                    return true;
                }
            });
        }
        return false;
    };
    MuObject.byReference = function (provider, path) {
        if (path === void 0) { path = []; }
        var result = new this();
        result.__value__ = new this.__refType(provider, path);
        return result;
    };
    MuObject.makeValue = function (value, options, errorContext) {
        return this.wrapValue(value, this._spec, options, errorContext);
    };
    MuObject.makeAdmin = function (name) {
        var $mobx = new FakeObjectAdministrator(name);
        if (config_1.default.observable) {
            _.each(this._spec, function (fieldSpec, key) {
                $mobx.atoms[key] = new mobx_1.BaseAtom("[" + name + "]." + key);
            });
        }
        return $mobx;
    };
    MuObject.wrapValue = function (value, spec, options, errorContext) {
        var _this = this;
        if (value === null) {
            return null;
        }
        var newValue = {};
        _.each(spec, function (fieldSpec, key) {
            var fieldVal = value[key];
            if (fieldVal === undefined) {
                fieldVal = spec[key].defaults();
            }
            var fieldErrorContext = errorContext ?
                _.defaults({ path: errorContext.path + '.' + key }, errorContext) :
                _this.createErrorContext(key, 'warn');
            newValue[key] = type_match_1.validateAndWrap(fieldVal, fieldSpec, undefined, fieldErrorContext);
        });
        return newValue;
    };
    MuObject.create = function (value, options, errorContext) {
        if (MuObject === utils_1.getPrimeType(this)) {
            return default_object_1.defaultObject(this.defaults());
        }
        else {
            return new this(value, options, errorContext);
        }
    };
    MuObject.prototype.getName = function () {
        return getClass(this).id + '#' + this.getRuntimeId();
    };
    // this method traverses the input recursively until it reaches mutable values (then it sets them)
    MuObject.prototype.setValue = function (newValue, errorContext) {
        var _this = this;
        if (errorContext === void 0) { errorContext = getClass(this).createErrorContext('setValue error', 'error'); }
        if (this.$isDirtyable()) {
            var changed_1 = false;
            _.forEach(newValue, function (fieldValue, fieldName) {
                var fieldSpec = getClass(_this)._spec[fieldName];
                if (fieldSpec) {
                    var fieldErrorContext = _.defaults({ path: errorContext.path + '.' + fieldName }, errorContext);
                    var newValue_1 = fieldSpec._matchValue(fieldValue, fieldErrorContext).wrap();
                    changed_1 = _this.$assignField(fieldName, newValue_1, fieldErrorContext) || changed_1;
                }
            });
            return changed_1;
        }
        return false;
    };
    // this method traverses the input recursively until it reaches mutable values (then it sets them)
    MuObject.prototype.setValueDeep = function (newValue, errorContext) {
        var _this = this;
        if (errorContext === void 0) { errorContext = getClass(this).createErrorContext('setValueDeep error', 'error'); }
        if (this.$isDirtyable()) {
            var changed_2 = false;
            _.forEach(getClass(this)._spec, function (fieldSpec, fieldName) {
                var inputFieldValue = newValue[fieldName];
                var fieldValue = (inputFieldValue !== undefined) ? inputFieldValue : fieldSpec.defaults();
                if (fieldValue === null || fieldSpec.validateType(fieldValue)) {
                    changed_2 = _this.$assignField(fieldName, fieldValue) || changed_2;
                }
                else {
                    var value = _this.__value__[fieldName];
                    if (value && value.setValueDeep && !value.$isReadOnly()) {
                        changed_2 = value.setValueDeep(fieldValue, errorContext) || changed_2;
                    }
                    else {
                        var fieldErrorContext = {
                            level: errorContext.level,
                            entryPoint: errorContext.entryPoint,
                            path: errorContext.path + '.' + fieldName
                        };
                        changed_2 = _this.$assignField(fieldName, type_match_1.validateAndWrap(fieldValue, fieldSpec, _this.__lifecycleManager__, fieldErrorContext), fieldErrorContext) || changed_2;
                    }
                }
            });
            return changed_2;
        }
        return false;
    };
    // validates and assigns input to field.
    // will report error for undefined fields
    // returns whether the field value has changed
    MuObject.prototype.$assignField = function (fieldName, newValue, errorContext) {
        // don't assign if input is the same as existing value
        if (utils_1.shouldAssign(this.__value__[fieldName], newValue)) {
            var fieldDef = getClass(this)._spec[fieldName];
            var checkTyped = newValue instanceof base_1.MuBase || validation_1.isAssignableFrom(base_1.MuBase, fieldDef);
            // for typed field, validate the type of the value. for untyped field (primitive), just validate the data itself
            if ((checkTyped && fieldDef.validateType(newValue)) || (!checkTyped && fieldDef.validate(newValue))) {
                var notifySpy = mobx_1.extras.isSpyEnabled();
                if (config_1.default.observable && notifySpy) {
                    mobx_1.extras.spyReportStart({
                        type: "update",
                        object: this,
                        name: fieldName,
                        newValue: newValue,
                        oldValue: this.__value__[fieldName]
                    });
                }
                this.__value__[fieldName] = newValue;
                lifecycle_1.optionalSetManager(newValue, this.__lifecycleManager__);
                if (config_1.default.observable) {
                    this.$mobx.atoms[fieldName].reportChanged();
                    if (notifySpy)
                        mobx_1.extras.spyReportEnd();
                }
                return true;
            }
            else {
                if (!errorContext) {
                    errorContext = this.__ctor__.createErrorContext('Set error', 'error');
                    errorContext.path = errorContext.path + '.' + fieldName;
                }
                MAILBOX.post(errorContext.level, validation_1.misMatchMessage(errorContext, fieldDef, newValue));
            }
        }
        return false;
    };
    MuObject.prototype.toJS = function (typed) {
        if (typed === void 0) { typed = false; }
        return {};
    };
    ;
    MuObject.prototype.toJSON = function (recursive, typed) {
        if (recursive === void 0) { recursive = true; }
        if (typed === void 0) { typed = false; }
        return {};
    };
    MuObject.prototype.$dirtyableElementsIterator = function (yielder) { };
    MuObject.prototype.$atomsIterator = function (yielder) { };
    return MuObject;
}(base_1.MuBase));
MuObject.id = 'Object';
MuObject._spec = Object.freeze(Object.create(null));
exports.MuObject = MuObject;
base_1.defineNonPrimitive('Object', MuObject);
//# sourceMappingURL=object.js.map