"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("../types");
var escalate_1 = require("escalate");
var utils_1 = require("../utils");
var lodash_1 = require("lodash");
var validation_1 = require("../core/validation");
var object_1 = require("./object");
var base_1 = require("../core/base");
var lodash_2 = require("lodash");
var template_object_methods_1 = require("./template-object-methods");
var MAILBOX = escalate_1.getMailBox('mutable.extend');
var RESERVED_FIELDS = Object.keys(lodash_1.extend({}, object_1.MuObject.prototype));
function defineClass(id, typeDefinition, parent, jsType) {
    parent = parent || object_1.MuObject;
    var type = jsType || utils_1.inherit(id, parent);
    if (!object_1.MuObject.isJsAssignableFrom(type)) {
        MAILBOX.fatal("Type definition error: " + id + " is not a subclass of Object");
    }
    base_1.defineNonPrimitive(id, type);
    calculateSchemaProperties(typeDefinition, type, parent, id);
    return type;
}
exports.defineClass = defineClass;
// values that are calculated from spec require Type to be defined (for recursive types) so they are attached to the class after definition
function calculateSchemaProperties(typeDefinition, type, parent, id) {
    var definedSpec = typeDefinition.spec(type);
    var effectiveSpec = parent && parent._spec ? lodash_1.clone(parent._spec) : {};
    lodash_1.forEach(definedSpec, function (fieldDef, fieldName) {
        if (validateField(type, parent._spec, fieldName, fieldDef, parent.id)) {
            effectiveSpec[fieldName] = fieldDef;
        }
    });
    type._spec = effectiveSpec;
    var complex = [];
    for (var k in definedSpec) {
        if (types_1.isNonPrimitiveType(definedSpec[k])) {
            complex[complex.length] = k;
        }
    }
    if (typeDefinition.transitiveOverrides) {
        type.options = lodash_2.defaults({ transitiveOverrides: type.options.transitiveOverrides.concat(typeDefinition.transitiveOverrides) }, type.options);
    }
    if (typeDefinition.staticTransitiveOverrides) {
        type.options = lodash_2.defaults({ staticTransitiveOverrides: type.options.staticTransitiveOverrides.concat(typeDefinition.staticTransitiveOverrides) }, type.options);
    }
    type.prototype.$dirtyableElementsIterator = template_object_methods_1.nonPrimitiveElementsIterator(complex, parent.prototype);
    type.prototype.$atomsIterator = template_object_methods_1.atomsIterator(definedSpec, parent.prototype);
    if (!~type.options.transitiveOverrides.indexOf('toJSON')) {
        type.prototype.toJSON = template_object_methods_1.toJSON(type);
    }
    if (!~type.options.transitiveOverrides.indexOf('toJS')) {
        type.prototype.toJS = template_object_methods_1.toJS(type);
    }
    lodash_1.forEach(definedSpec, function (fieldDef, fieldName) {
        Object.defineProperty(type.prototype, fieldName, template_object_methods_1.fieldAttribute(fieldName));
    });
    type.__refType = generateRefType(type);
}
function validateField(type, parentSpec, fieldName, fieldDef, parentName) {
    var error = null;
    var errorContext = object_1.MuObject.createErrorContext("Type definition error", 'fatal');
    var path = type.id + "." + fieldName;
    // TODO validate (sanitize) field name against js injection
    if (~RESERVED_FIELDS.indexOf(fieldName)) {
        error = 'is a reserved field.';
    }
    else if (parentSpec[fieldName]) {
        error = "already exists on super " + parentName;
    }
    else {
        var err = utils_1.reportFieldDefinitionError(fieldDef);
        if (err) {
            error = err.message;
            if (err.path) {
                path = path + err.path;
            }
        }
    }
    if (error) {
        MAILBOX.fatal("Type definition error: \"" + path + "\" " + error);
    }
    else {
        error = fieldDef.reportSetValueErrors(fieldDef.defaults());
        if (error) {
            MAILBOX.post(errorContext.level, validation_1.misMatchMessage(errorContext, fieldDef, fieldDef.defaults(), path));
        }
    }
    return !error;
}
// TODO: find a place for the reference type
function getReference(rootReference, path, thisType, fieldDef, fieldName) {
    var value = utils_1.getValueFromRootRef(rootReference, path);
    return utils_1.getReferenceWrapper(thisType, fieldDef, rootReference, path.concat(fieldName), value[fieldName]);
}
function generateRefType(type) {
    var Reference = (function () {
        function Reference(__origin, path) {
            this.__origin = __origin;
            this.path = path;
        }
        return Reference;
    }());
    lodash_1.forEach(type._spec, function (fieldDef, fieldName) {
        Object.defineProperty(Reference.prototype, fieldName, {
            get: function () {
                return getReference(this.__origin, this.path, type, fieldDef, fieldName);
            },
            enumerable: true,
            configurable: false
        });
    });
    return Reference;
}
//# sourceMappingURL=define.js.map