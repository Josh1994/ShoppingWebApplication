"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var escalate_1 = require("escalate");
var config_1 = require("../config");
var MAILBOX = escalate_1.getMailBox('mutable.extend');
function nonPrimitiveElementsIterator(nonPrimitiveFields, parent) {
    return function typeDirtyableElementsIterator(yielder) {
        for (var _i = 0, nonPrimitiveFields_1 = nonPrimitiveFields; _i < nonPrimitiveFields_1.length; _i++) {
            var c = nonPrimitiveFields_1[_i];
            var k = this.__value__[c];
            if (k && lodash_1.isFunction(k.$setManager)) {
                yielder(this, k);
            }
        }
        parent && lodash_1.isFunction(parent.$dirtyableElementsIterator) && parent.$dirtyableElementsIterator.call(this, yielder);
    };
}
exports.nonPrimitiveElementsIterator = nonPrimitiveElementsIterator;
function atomsIterator(spec, parent) {
    return function atomsIterator(yielder) {
        if (config_1.default.observable) {
            for (var c in spec) {
                if (spec.hasOwnProperty(c)) {
                    yielder(this.$mobx.atoms[c]);
                }
            }
            parent && lodash_1.isFunction(parent.$atomsIterator) && parent.$atomsIterator.call(this, yielder);
        }
    };
}
exports.atomsIterator = atomsIterator;
function deepClone(clazz, recCaller) {
    return function (recursive, typed) {
        var _this = this;
        if (recursive === void 0) { recursive = true; }
        if (typed === void 0) { typed = false; }
        var result = Object.keys(clazz._spec).reduce(function (clone, key) {
            if (config_1.default.observable) {
                _this.$mobx.atoms[key].reportObserved();
            }
            var fieldValue = _this.__value__[key];
            clone[key] = recursive ? recCaller(fieldValue, typed) : fieldValue;
            return clone;
        }, {});
        if (typed) {
            result._type = clazz.id;
        }
        return result;
    };
}
function recursiveCallToJs(fieldValue, typed) {
    return (fieldValue && fieldValue.toJS) ? fieldValue.toJS(typed) : fieldValue;
}
function recursiveCallToJson(fieldValue, typed) {
    return (fieldValue && fieldValue.toJSON) ? fieldValue.toJSON(true, typed) : fieldValue;
}
function toJS(clazz) {
    var cloneFn = deepClone(clazz, recursiveCallToJs);
    return function toJS(typed) {
        if (typed === void 0) { typed = false; }
        return cloneFn.call(this, true, typed);
    };
}
exports.toJS = toJS;
function toJSON(clazz) {
    var cloneFn = deepClone(clazz, recursiveCallToJson);
    return function toJSON(recursive, typed) {
        if (recursive === void 0) { recursive = true; }
        if (typed === void 0) { typed = false; }
        return cloneFn.call(this, recursive, typed);
    };
}
exports.toJSON = toJSON;
function fieldAttribute(fieldName) {
    return {
        get: function () {
            if (config_1.default.observable) {
                this.$mobx.atoms[fieldName].reportObserved();
            }
            var value = this.__value__[fieldName];
            if (!this.__isReadOnly__ || value === null || value === undefined || !value.$asReadOnly) {
                return value;
            }
            else {
                return value.$asReadOnly();
            }
        },
        set: function (newValue) {
            if (this.$isDirtyable()) {
                this.$assignField(fieldName, newValue);
            }
            else {
                MAILBOX.warn("Attempt to override a read only value " + JSON.stringify(this.__value__[fieldName]) + " at " + this.constructor.id + "." + fieldName + " with " + JSON.stringify(newValue));
            }
        },
        enumerable: true,
        configurable: false
    };
}
exports.fieldAttribute = fieldAttribute;
//# sourceMappingURL=template-object-methods.js.map