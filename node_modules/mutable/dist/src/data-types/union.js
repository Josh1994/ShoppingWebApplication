"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var escalate_1 = require("escalate");
var base_1 = require("./../core/base");
var validation_1 = require("./../core/validation");
var type_match_1 = require("./../core/type-match");
var generic_types_1 = require("../core/generic-types");
var MAILBOX = escalate_1.getMailBox('mutable.Union');
function getTypeName(type) {
    var result = type.id || type.name || type.id;
    if (type.options) {
        var subTypes = type.options.subTypes;
        if (subTypes) {
            // let genericSubtypesArr = Object.keys(subTypes).map(k => subTypes[k]);
            result = result + generic_types_1.toString.apply(void 0, subTypes);
        }
    }
    return result;
}
var Union = (function (_super) {
    __extends(Union, _super);
    function Union(value, options, errorContext) {
        var _this = this;
        MAILBOX.error('Instantiating a union type is not supported');
        _this = _super.call(this, value, options, errorContext) || this;
        return _this;
    }
    Union.defaults = function () {
        if (!this.options || !this.options.subTypes) {
            MAILBOX.error('Untyped Unions are not supported. please state union of types in the format string|number');
        }
        else {
            return this.options.subTypes[0].defaults();
        }
    };
    Union.of = function (subTypes) {
        var result = this.withDefault(undefined, undefined, { subTypes: subTypes });
        result.id = subTypes.map(generic_types_1.toUnwrappedString).join('|');
        return result;
    };
    ;
    Union.getTypes = function () {
        if (!this.options || !this.options.subTypes) {
            MAILBOX.error('Untyped Unions are not supported. please state union of types in the format string|number');
        }
        else {
            return this.options.subTypes.reduce(function (subTypes, type) {
                subTypes[getTypeName(type)] = type;
                return subTypes;
            }, {});
        }
    };
    Union.allowPlainVal = function (value, errorDetails) {
        return validation_1.validateNullValue(this, value) ||
            !!(this.options && this.options.subTypes &&
                this.options.subTypes.some(function (typeDef) { return typeDef.allowPlainVal(value, errorDetails); }));
    };
    Union.validate = function (value) {
        return validation_1.validateNullValue(this, value) ||
            !!(this.options && this.options.subTypes &&
                _.some(this.options.subTypes, function (typeDef) {
                    return typeDef.validate(value);
                }));
    };
    Union._matchValue = function (value, errorContext) {
        if (!this.options || !this.options.subTypes) {
            MAILBOX.error('Untyped Unions are not supported. please state union of types in the format string|number');
        }
        else if (!this.isNullable() || value !== null) {
            return (_a = new type_match_1.TypeMatch(value, errorContext)).tryTypes.apply(_a, this.options.subTypes);
        }
        return new type_match_1.TypeMatch(value, errorContext).tryType(this);
        var _a;
    };
    Union.validateType = function (value) {
        return (this.options && this.options.subTypes &&
            _.some(this.options.subTypes, function (typeDef) {
                return typeDef.validateType(value);
            })) || validation_1.validateNullValue(this, value);
    };
    Union.cloneValue = function (value) {
        if (!this.options || !this.options.subTypes) {
            MAILBOX.error('Untyped Unions are not supported. please state union of types in the format string|number');
        }
        else {
            return this.options.subTypes[0].cloneValue(value);
        }
    };
    Union.create = function (value, options, errorContext) {
        errorContext = errorContext || this.createErrorContext('Type constructor error', 'error');
        if (!this.options || !this.options.subTypes) {
            MAILBOX.error('Untyped Unions are not supported. please state union of types in the format string|number');
        }
        else {
            var matchedSubType = _.find(this.options.subTypes, function (type) { return type.allowPlainVal(value); });
            if (matchedSubType) {
                return matchedSubType.create(value, options, errorContext);
            }
            else {
                MAILBOX.error(validation_1.misMatchMessage(errorContext, this.id, value));
            }
        }
    };
    Union.prototype.$dirtyableElementsIterator = function (yielder) { MAILBOX.error('Instantiating a union type is not supported'); };
    Union.prototype.$atomsIterator = function (yielder) { MAILBOX.error('Instantiating a union type is not supported'); };
    Union.prototype.setValue = function (newValue, errorContext) { MAILBOX.error('Instantiating a union type is not supported'); return false; };
    Union.prototype.setValueDeep = function (newValue, errorContext) { MAILBOX.error('Instantiating a union type is not supported'); return false; };
    Union.prototype.toJSON = function (recursive, typed) { MAILBOX.error('Instantiating a union type is not supported'); };
    Union.prototype.toJS = function (typed) { MAILBOX.error('Instantiating a union type is not supported'); };
    return Union;
}(base_1.MuBase));
exports.default = Union;
base_1.defineNonPrimitive('Union', Union);
//# sourceMappingURL=union.js.map