"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var escalate_1 = require("escalate");
var array_wrapper_1 = require("./array-wrapper");
var validation_1 = require("./../core/validation");
var type_match_1 = require("./../core/type-match");
var utils_1 = require("./../utils");
var base_1 = require("./../core/base");
var generics = require("./../core/generic-types");
var mobx_1 = require("mobx");
var lifecycle_1 = require("./../core/lifecycle");
var config_1 = require("../config");
var MAILBOX = escalate_1.getMailBox('mutable.List');
function isArray(val) {
    return _.isArray(val) || (val && val.constructor && val.constructor.name === "ObservableArray");
}
var ArrayReference = (function (_super) {
    __extends(ArrayReference, _super);
    function ArrayReference(rootReference, path, thisType) {
        return _super.call(this, function () { return utils_1.getValueFromRootRef(rootReference, path); }, function (value, idx) { return utils_1.getReferenceWrapper(thisType, thisType.options.subTypes, rootReference, path.concat(idx), value); }) || this;
    }
    return ArrayReference;
}(array_wrapper_1.ArrayWrapper));
var List = (function (_super) {
    __extends(List, _super);
    function List(value, options, errorContext) {
        if (value === void 0) { value = []; }
        if (options === void 0) { options = {}; }
        var _this = this;
        if (!errorContext) {
            errorContext = List.createErrorContext('List constructor error', 'error', options);
        }
        options.subTypes = generics.typesAsArray(options.subTypes);
        _this = _super.call(this, value, options, errorContext) || this;
        var report = _this.__ctor__.reportDefinitionErrors();
        if (report) {
            MAILBOX.error('List constructor: ' + report.message);
        }
        return _this;
    }
    List.defaults = function () { return []; };
    List.cloneValue = function (value) {
        var _this = this;
        if (isArray(value) || List.validateType(value)) {
            if (!value) {
                return value;
            }
            return value.map(function (itemValue, index) {
                var Type = generics.getMatchingType(_this.options.subTypes, itemValue);
                if (!Type) {
                    throw new Error('cloneValue error: no type found for index ' + index);
                }
                return Type.cloneValue(itemValue);
            });
        }
        else {
            return [];
        }
    };
    List.validate = function (value) { return validation_1.validateNullValue(this, value) || isArray(value); };
    List.allowPlainVal = function (value, errorDetails) {
        var _this = this;
        if (errorDetails === void 0) { errorDetails = null; }
        if (validation_1.validateNullValue(this, value)) {
            return true;
        }
        else if (!isArray(value)) {
            return false;
        }
        return !this.options || !this.options.subTypes ||
            value.every(function (element, idx) {
                if (!generics.getMatchingType(_this.options.subTypes, element)) {
                    if (errorDetails) {
                        errorDetails.path = errorDetails.path + "[" + idx + "]";
                        errorDetails.expected = generics.toString(_this.options.subTypes);
                        errorDetails.actual = element;
                    }
                    return false;
                }
                else {
                    return true;
                }
            });
    };
    List.makeValue = function (value, options, errorContext) {
        var _this = this;
        var toWrap;
        if (this.validateType(value)) {
            if (value.__value__.map) {
                toWrap = value.__value__.map(function (itemValue) {
                    return _this._wrapSingleItem(itemValue, options, null, errorContext);
                }, this);
            }
            else {
                MAILBOX.error('Unmet mutable type requirement.');
            }
        }
        else if (!isArray(value)) {
            MAILBOX.error('Unmet array type requirement.');
        }
        else {
            toWrap = value.map(function (itemValue, itemIndex) {
                return _this._wrapSingleItem(itemValue, options, null, {
                    level: errorContext.level,
                    entryPoint: errorContext.entryPoint,
                    path: errorContext.path + '[' + itemIndex + ']'
                });
            }, this);
        }
        return config_1.default.observable ? mobx_1.observable.shallowArray(toWrap) : toWrap;
    };
    List._wrapSingleItem = function (value, options, lifeCycle, errorContext) {
        var result = generics.doOnType(options.subTypes, function (type) {
            if (type.validateType(value) || type.allowPlainVal(value)) {
                return type_match_1.validateAndWrap(value, type, lifeCycle, errorContext);
            }
        });
        if (null === result || undefined === result) {
            var allowedTypes = generics.toString(options.subTypes);
            MAILBOX.post(errorContext.level, validation_1.misMatchMessage(errorContext, allowedTypes, value));
        }
        else {
            return result;
        }
    };
    List.of = function (subTypes) {
        //TODO: remove this when transpiler shenanigans are over
        if (arguments.length > 1) {
            subTypes = Array.prototype.slice.call(arguments);
        }
        return this.withDefault(undefined, undefined, { subTypes: subTypes });
    };
    ;
    List.reportDefinitionErrors = function () {
        if (!this.options || !this.options.subTypes) {
            return { path: '', message: "Untyped Lists are not supported please state type of list item in the format core3.List<string>" };
        }
        else {
            var error = generics.reportDefinitionErrors(this.options.subTypes, utils_1.reportFieldDefinitionError);
            if (error) {
                return {
                    path: "<" + error.path + ">",
                    message: error.message
                };
            }
        }
    };
    List.createErrorContext = function (entryPoint, level, options) {
        options = options || this.options || this.__options__;
        return {
            level: level,
            entryPoint: entryPoint,
            path: 'List' + generics.toString(generics.typesAsArray(options.subTypes))
        };
    };
    List.byReference = function (provider, path) {
        if (path === void 0) { path = []; }
        // wrap provider
        var result = new this();
        result.__value__ = new ArrayReference(provider, path, this);
        return result;
    };
    List.prototype.toJSON = function (recursive, typed) {
        var _this = this;
        if (recursive === void 0) { recursive = true; }
        if (typed === void 0) { typed = false; }
        return this.__value__.map(function (item) {
            if (base_1.MuBase.validateType(item) && _this.__isReadOnly__) {
                item = item.$asReadOnly();
            }
            return (recursive && base_1.MuBase.validateType(item)) ? item.toJSON(true, typed) : item;
        });
    };
    List.prototype.toJS = function (typed) {
        var _this = this;
        if (typed === void 0) { typed = false; }
        return this.__value__.map(function (item) {
            if (base_1.MuBase.validateType(item) && _this.__isReadOnly__) {
                item = item.$asReadOnly();
            }
            return item && item.toJS ? item.toJS(typed) : item;
        });
    };
    List.prototype.__lodashProxyWrap__ = function (key, fn, ctx) {
        if (!_.isUndefined(ctx)) {
            if (_.isFunction(fn)) {
                fn = _.bind(fn, ctx);
            }
            else {
                fn = _.matchesProperty(fn, ctx);
            }
        }
        var valueArray = _[key](this.__getValueArr__(), fn);
        return this.__wrapArr__(valueArray);
    };
    List.prototype.__lodashProxy__ = function (key, fn, ctx) {
        if (!_.isUndefined(ctx)) {
            if (_.isFunction(fn)) {
                fn = _.bind(fn, ctx);
            }
            else {
                fn = _.matchesProperty(fn, ctx);
            }
        }
        var valueArray = _[key](this.__getValueArr__(), fn);
        return valueArray;
    };
    List.prototype.__getLodashIterateeWrapper__ = function (iteratee, allowObj) {
        if (_.isFunction(iteratee)) {
            var mutableArr = this;
            return function (item, index) {
                return iteratee.call(this, item, index, mutableArr);
            };
        }
        else if (allowObj && _.isObject(iteratee)) {
            if (!iteratee.constructor || !iteratee.constructor.type) {
                iteratee = this.constructor._wrapSingleItem(iteratee, this.__options__, null);
            }
            return function wrappedObjMatchIterator(element) {
                // TODO add matches implementation in List and Map
                return iteratee.matches(element);
            };
        }
        else {
            return iteratee;
        }
    };
    List.prototype.__getValueArr__ = function () {
        if (this.__isReadOnly__) {
            return this.__value__.map(function (item) {
                return (item.$asReadOnly) ? item.$asReadOnly() : item;
            });
        }
        else {
            return this.__value__.map(function (item) {
                return item;
            });
        }
    };
    List.prototype.__wrapArr__ = function (val) {
        return new this.constructor(val, this.__options__);
    };
    // Mutator methods
    List.prototype.pop = function () {
        if (this.$isDirtyable()) {
            return this.__value__.pop();
        }
        else {
            return null;
        }
    };
    List.prototype.push = function () {
        var _this = this;
        var newItems = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newItems[_i] = arguments[_i];
        }
        if (this.$isDirtyable()) {
            return Array.prototype.push.apply(this.__value__, newItems.map(function (item, idx) {
                var errorContext = _this.constructor.createErrorContext('List push error', 'error', _this.__options__);
                mobx_1.untracked(function () { errorContext.path += "[" + (_this.__value__.length + idx) + "]"; });
                return _this.constructor._wrapSingleItem(item, _this.__options__, _this.__lifecycleManager__, errorContext);
            }));
        }
        else {
            return null;
        }
    };
    List.prototype.shift = function () {
        if (this.$isDirtyable()) {
            return this.__value__.shift();
        }
        else {
            return null;
        }
    };
    List.prototype.sort = function (compareFn) {
        return this.__wrapArr__(this.__value__.sort(compareFn));
    };
    List.prototype.reverse = function () {
        return this.__wrapArr__(this.__value__.reverse());
    };
    List.prototype.splice = function (index, removeCount) {
        var addedItems = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            addedItems[_i - 2] = arguments[_i];
        }
        if (this.$isDirtyable()) {
            var spliceParams = [index, removeCount];
            addedItems.forEach(function (newItem, idx) {
                var errorContext = this.constructor.createErrorContext('List splice error', 'error', this.__options__);
                errorContext.path += "[" + (index + idx) + "]";
                spliceParams.push(this.constructor._wrapSingleItem(newItem, this.__options__, this.__lifecycleManager__, errorContext));
            }.bind(this));
            return this.__value__.splice.apply(this.__value__, spliceParams);
            //return this.__value__.push(this.constructor._wrapSingleItem(newItem, this.__isReadOnly__, this.__options__));
        }
        else {
            return null;
        }
    };
    List.prototype.unshift = function () {
        var _this = this;
        var newItems = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newItems[_i] = arguments[_i];
        }
        if (this.$isDirtyable()) {
            return this.__value__.unshift.apply(this.__value__, newItems.map(function (item, idx) {
                var errorContext = _this.constructor.createErrorContext('List unshift error', 'error', _this.__options__);
                errorContext.path += "[" + idx + "]";
                return _this.constructor._wrapSingleItem(item, _this.__options__, _this.__lifecycleManager__, errorContext);
            }));
        }
        else {
            return null;
        }
    };
    List.prototype.$assignCell = function (index, newValue, errorContext) {
        var _this = this;
        if (mobx_1.untracked(function () { return utils_1.shouldAssign(_this.__value__[index], newValue); })) {
            lifecycle_1.optionalSetManager(newValue, this.__lifecycleManager__);
            this.__value__[index] = newValue;
            return true;
        }
        return false;
    };
    List.prototype.set = function (index, element) {
        if (this.$isDirtyable()) {
            var errorContext = this.constructor.createErrorContext('List set error', 'error', this.__options__);
            var newValue = this.constructor._wrapSingleItem(element, this.__options__, this.__lifecycleManager__, errorContext);
            return this.$assignCell(index, newValue, errorContext) ? newValue : null;
        }
        return null;
    };
    // Accessor methods
    List.prototype.at = function (index) {
        var _this = this;
        if (index >= 0 && mobx_1.untracked(function () { return _this.__value__.length > index; })) {
            var item = this.__value__[index];
            return (base_1.MuBase.validateType(item) && this.__isReadOnly__) ? item.$asReadOnly() : item;
        }
    };
    List.prototype.concat = function () {
        var addedArrays = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            addedArrays[_i] = arguments[_i];
        }
        return this.__wrapArr__((_a = this.__getValueArr__()).concat.apply(_a, addedArrays.map(function (array) { return array.__getValueArr__ ? array.__getValueArr__() : array; })));
        var _a;
    };
    List.prototype.join = function (separator) {
        if (separator === void 0) { separator = ','; }
        return this.__value__.join(separator);
    };
    List.prototype.slice = function (begin, end) {
        return this.__wrapArr__(this.__getValueArr__().slice(begin, end));
    };
    List.prototype.toString = function () {
        return this.__value__.peek().toString();
    };
    List.prototype.valueOf = function () {
        return this.__value__.map(function (item) {
            return item.valueOf();
        });
    };
    List.prototype.toLocaleString = function () {
        MAILBOX.fatal('toLocaleString not implemented yet. Please do.');
    };
    List.prototype.indexOf = function (searchElement, fromIndex) {
        return this.__value__.indexOf(searchElement, fromIndex || 0);
    };
    List.prototype.lastIndexOf = function (searchElement, fromIndex) {
        return this.__value__.lastIndexOf(searchElement, fromIndex || this.__value__.length);
    };
    // Iteration methods
    List.prototype.forEach = function (iteratee, ctx) {
        this.__lodashProxy__('forEach', this.__getLodashIterateeWrapper__(iteratee, false), ctx);
    };
    List.prototype.find = function (predicate, ctx) {
        return this.__lodashProxy__('find', this.__getLodashIterateeWrapper__(predicate, true), ctx);
    };
    List.prototype.findIndex = function (predicate, ctx) {
        return this.__lodashProxy__('findIndex', this.__getLodashIterateeWrapper__(predicate, true), ctx);
    };
    List.prototype.map = function (iteratee, ctx) {
        return this.__lodashProxy__('map', this.__getLodashIterateeWrapper__(iteratee, true), ctx);
    };
    List.prototype.reduce = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return _.reduce.apply(_, [this.__getValueArr__()].concat(args));
    };
    List.prototype.every = function (fn, ctx) {
        return this.__lodashProxy__('every', this.__getLodashIterateeWrapper__(fn, true), ctx);
    };
    List.prototype.some = function (fn, ctx) {
        return this.__lodashProxy__('some', this.__getLodashIterateeWrapper__(fn, true), ctx);
    };
    List.prototype.filter = function (fn, ctx) {
        return this.__lodashProxyWrap__('filter', this.__getLodashIterateeWrapper__(fn, true), ctx);
    };
    List.prototype.setValue = function (newValue, errorContext) {
        var _this = this;
        var changed = false;
        if (newValue instanceof List) {
            newValue = newValue.__getValueArr__();
        }
        if (isArray(newValue)) {
            var lengthDiff = this.__value__.length - newValue.length;
            if (lengthDiff > 0) {
                // current array is longer than newValue, fill the excess cells with undefined
                changed = true;
                this.__value__.splice(newValue.length, lengthDiff);
            }
            _.forEach(newValue, function (itemValue, idx) {
                var errorContext = errorContext ? utils_1.clone(errorContext) : _this.constructor.createErrorContext('List setValue error', 'error', _this.__options__);
                errorContext.path += "[" + idx + "]";
                var newItemVal = _this.constructor._wrapSingleItem(itemValue, _this.__options__, _this.__lifecycleManager__, errorContext);
                if (_this.__value__.length <= idx) {
                    _this.__value__.push(newItemVal);
                    changed = true;
                }
                else {
                    changed = _this.$assignCell(idx, newItemVal, errorContext) || changed;
                }
            });
            this.__value__.length = newValue.length;
        }
        return changed;
    };
    List.prototype.setValueDeep = function (newValue, errorContext) {
        var _this = this;
        if (errorContext === void 0) { errorContext = null; }
        var changed = false;
        if (newValue instanceof List) {
            newValue = newValue.__getValueArr__();
        }
        if (isArray(newValue)) {
            changed = this.length !== newValue.length;
            var assignIndex_1 = 0;
            var errorContext_1 = errorContext_1 ? utils_1.clone(errorContext_1) : this.constructor.createErrorContext('List setValueDeep error', 'error', this.__options__);
            _.forEach(newValue, function (itemValue, newValIndex) {
                var isPassedArrayLength = _this.length <= assignIndex_1;
                var currentItem = isPassedArrayLength ? undefined : mobx_1.untracked(function () { return _this.__value__[assignIndex_1]; });
                if (!isPassedArrayLength && (typeof currentItem === 'null' || typeof currentItem === 'undefined')) {
                    MAILBOX.post(errorContext_1.level, errorContext_1.entryPoint + ": \"" + errorContext_1.path + "\" List setValueDeep() is not implemented for null cells yet");
                }
                else if (isPassedArrayLength) {
                    changed = true;
                    _this.__value__[assignIndex_1] = _this.constructor._wrapSingleItem(itemValue, _this.__options__, _this.__lifecycleManager__, errorContext_1);
                }
                else if (_this.__options__.subTypes.validateType(itemValue)) {
                    changed = _this.$assignCell(assignIndex_1, itemValue, errorContext_1) || changed;
                }
                else if (currentItem.setValueDeep && !base_1.MuBase.validateType(itemValue) && !currentItem.$isReadOnly()) {
                    if (currentItem.constructor.allowPlainVal(itemValue)) {
                        changed = currentItem.setValueDeep(itemValue) || changed;
                    }
                    else {
                        var newValue_1 = _this.constructor._wrapSingleItem(itemValue, _this.__options__, _this.__lifecycleManager__, errorContext_1);
                        changed = _this.$assignCell(assignIndex_1, newValue_1, errorContext_1) || changed;
                    }
                }
                else {
                    var newValue_2 = _this.constructor._wrapSingleItem(itemValue, _this.__options__, _this.__lifecycleManager__, errorContext_1);
                    changed = _this.$assignCell(assignIndex_1, newValue_2, errorContext_1) || changed;
                }
                assignIndex_1++;
            });
            this.__value__.length = newValue.length;
        }
        return changed;
    };
    /**
     * get iterator over all array elements that are dirtyable
     */
    // consider optimizing if array is of primitive type only
    List.prototype.$dirtyableElementsIterator = function (yielder) {
        for (var i = 0; i < this.__value__.length; i++) {
            var element = this.__value__[i];
            if (element && _.isFunction(element.$setManager)) {
                yielder(this, element);
            }
        }
    };
    List.prototype.$atomsIterator = function (yielder) {
        if (config_1.default.observable) {
            yielder(mobx_1.extras.getAtom(this.__value__));
        }
    };
    Object.defineProperty(List.prototype, "length", {
        get: function () {
            return this.__value__.length;
        },
        set: function (newLength) {
            this.__value__.length = newLength;
        },
        enumerable: true,
        configurable: true
    });
    return List;
}(base_1.MuBase));
exports.default = List;
base_1.defineNonPrimitive('List', List);
//# sourceMappingURL=list.js.map