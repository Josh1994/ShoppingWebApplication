"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var config_1 = require("./config");
var escalate_1 = require("escalate");
var MAILBOX = escalate_1.getMailBox('mutable.utils');
var types_1 = require("./types");
function isDevMode() {
    return config_1.default.devMode;
}
exports.isDevMode = isDevMode;
var ClassesCounter = 0;
function generateClassId() {
    return ClassesCounter++;
}
exports.generateClassId = generateClassId;
var CLONE_KEY = '@activeClone';
function isComplex(obj) {
    return obj !== null && typeof (obj) === 'object';
}
function clone(arg, isDeep) {
    if (isDeep === void 0) { isDeep = false; }
    if (isComplex(arg)) {
        var obj = arg;
        if (obj[CLONE_KEY] === undefined) {
            var cloned = obj.constructor ? obj.constructor() : {};
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    if (isDeep) {
                        obj[CLONE_KEY] = null;
                        cloned[key] = clone(obj[key]);
                        delete obj[CLONE_KEY];
                    }
                    else {
                        cloned[key] = obj[key];
                    }
                }
            }
            return cloned;
        }
    }
    return arg;
}
exports.clone = clone;
// in case T is nullable, the result will be a little different
function getPrimeType(type) {
    return (type && type._prime || type);
}
exports.getPrimeType = getPrimeType;
exports.__extends = (this && this.__extends) || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
function anonymousInherit(id, parent, superArgsMutator) {
    var type = Type;
    var _super = parent;
    function Type(value, options, errorContext) {
        return _super.apply(this, superArgsMutator ? superArgsMutator(type, value, options, errorContext) : [value, options, errorContext]) || this;
    }
    return type;
}
var classNameRegExp = /^(?:[\$A-Z_a-z])(?:[\$0-9A-Z_a-z])*$/;
var unionClassDelimitter = /\|/gi;
function namedInherit(id, parent, superArgsMutator) {
    var safeId = id.replace(unionClassDelimitter, '_or_');
    if (!classNameRegExp.test(safeId)) {
        MAILBOX.info("illegal class name \"" + safeId + "\", using \"Type\" instead");
        safeId = 'Type';
    }
    var type = types_1.cast(new Function('parent', 'superArgsMutator', "return function " + safeId + "(value, options, errorContext) {\n    return parent." + (superArgsMutator ? "apply(this, superArgsMutator(" + safeId + ", value, options, errorContext))" : 'call(this, value, options, errorContext)') + " || this;\n    };")(parent, superArgsMutator));
    return type;
}
function shouldAssign(a, b) {
    return b !== undefined && a !== b && !(_.isNaN(a) && _.isNaN(b));
}
exports.shouldAssign = shouldAssign;
var makeSuper = isDevMode() ? namedInherit : anonymousInherit;
function inherit(id, parent, superArgsMutator) {
    var type = makeSuper(id, parent, superArgsMutator);
    exports.__extends(type, parent);
    type.__proto__ = Object.create(parent); // inherit static properties of parent's prototype
    return type;
}
exports.inherit = inherit;
function clonedPreSuper(type, value, options, errorContext) {
    return [value === undefined ? type.defaults() : value,
        options ? _.assign({}, type.options, options) : type.options,
        errorContext];
}
exports.defaultClassOptions = {
    nullable: false,
    staticTransitiveOverrides: [],
    transitiveOverrides: []
};
/**
 * js inheritence for configuration override (used for .nullable(), .of(), .withDefault()...)
 */
function cloneType(id, TypeToClone, options) {
    var type = inherit(id, TypeToClone, clonedPreSuper);
    type._prime = getPrimeType(TypeToClone);
    type.options = _.defaults(options || {}, TypeToClone.options);
    type.__proto__ = Object.create(TypeToClone); // inherint non-enumerable static properties
    return type;
}
exports.cloneType = cloneType;
function getReadableValueTypeName(value) {
    if (value === null)
        return 'null';
    if (value === undefined)
        return 'undefined';
    if (value.constructor && value.constructor.id) {
        return value.constructor.id;
    }
    if (typeof value === 'object' && typeof value._type === 'string') {
        return 'object with _type ' + value._type;
    }
    return typeof value;
}
exports.getReadableValueTypeName = getReadableValueTypeName;
function getValueFromRootRef(rootReference, path) {
    var value = rootReference();
    // TODO add checks (the entire path should be objects, arrays or functions)
    for (var i = 0; i < path.length; i++) {
        value = value[path[i]];
    }
    return value;
}
exports.getValueFromRootRef = getValueFromRootRef;
function getReferenceWrapper(thisType, fieldDef, rootReference, path, value) {
    var fieldErrorContext = thisType.createErrorContext('get reference error', 'error');
    return fieldDef._matchValue(value, fieldErrorContext).byReference(rootReference, path);
}
exports.getReferenceWrapper = getReferenceWrapper;
function reportFieldDefinitionError(fieldDef) {
    if (!types_1.isType(fieldDef)) {
        return { message: "must be a primitive type or extend core3.Type", path: '' };
    }
    else if (types_1.isNonPrimitiveType(fieldDef)) {
        return fieldDef.reportDefinitionErrors();
    }
}
exports.reportFieldDefinitionError = reportFieldDefinitionError;
//# sourceMappingURL=utils.js.map