"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testDrivers_1 = require("escalate/dist/test-kit/testDrivers");
var test_drivers_1 = require("../test-kit/test-drivers");
var mutable = require("../src");
var generic_types_1 = require("../src/core/generic-types");
var reports_1 = require("../test-kit/test-drivers/reports");
var type_compatibility_contract_1 = require("./type-compatibility.contract");
describe('defining', function () {
    var Type1, Type2;
    before('define types', function () {
        Type1 = test_drivers_1.aDataTypeWithSpec({ foo: mutable.String }, 'Type1');
        Type2 = test_drivers_1.aDataTypeWithSpec({ type: Type1 }, 'Type2');
    });
    describe('String with default value', function () {
        type_compatibility_contract_1.typeCompatibilityTest(function () { return mutable.String.withDefault('im special!'); }, true);
    });
    describe('Number with default value', function () {
        type_compatibility_contract_1.typeCompatibilityTest(function () { return mutable.Number.withDefault(6); }, true);
    });
    describe('Boolean with default value', function () {
        type_compatibility_contract_1.typeCompatibilityTest(function () { return mutable.Boolean.withDefault(true); }, true);
    });
    it('a subclass without propper mutable definition', function () {
        var MyType = (function (_super) {
            __extends(MyType, _super);
            function MyType() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return MyType;
        }(mutable.Object));
        chai_1.expect(function () {
            new MyType();
        }).to.report(reports_1.ERROR_BAD_TYPE('Object', 'MyType'));
    });
    it('a defined subclass that uses Any as a polymorphic field', function () {
        var Type = test_drivers_1.aDataTypeWithSpec({ wrapped: mutable.Any }, 'Type');
        chai_1.expect(new Type().toJS()).to.eql({ wrapped: {} });
    });
    it('a defined subclass that uses MuBase as a polymorphic field', function () {
        var Type = test_drivers_1.aDataTypeWithSpec({ wrapped: mutable.Base }, 'Type');
        chai_1.expect(new Type().toJS()).to.eql({ wrapped: {} });
    });
    it('a defined subclass that uses MuObject as a polymorphic field', function () {
        var Type = test_drivers_1.aDataTypeWithSpec({ wrapped: mutable.Object }, 'Type');
        chai_1.expect(new Type().toJS()).to.eql({ wrapped: {} });
    });
    describe('a defined subclass that declares overriding methods', function () {
        var Parent, Child;
        beforeEach(function () {
            var Foo = (function (_super) {
                __extends(Foo, _super);
                function Foo() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Foo.wrapValue = function () { return 'foo'; };
                Foo.prototype.toJS = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return 'bar';
                };
                return Foo;
            }(mutable.Object));
            Parent = mutable.define('Parent', {
                staticTransitiveOverrides: ['wrapValue'],
                transitiveOverrides: ['toJS'],
                spec: function () { return ({}); }
            }, undefined, Foo);
            Child = mutable.define('Child', {
                spec: function () { return ({ wrapped: mutable.Number }); }
            }, Parent);
        });
        it('prevents mutable from from overriding a static method.', function () {
            chai_1.expect(Parent.wrapValue()).to.eql('foo');
        });
        it('prevents mutable from from overriding an instance method.', function () {
            chai_1.expect(new Parent().toJS()).to.eql('bar');
        });
        it('prevents mutable from from overriding a static method for sub classes', function () {
            chai_1.expect(Child.wrapValue()).to.eql('foo');
        });
        it('prevents mutable from from overriding an instance method for sub classes', function () {
            chai_1.expect(new Child().toJS()).to.eql('bar');
        });
    });
    describe('a basic type', function () {
        type_compatibility_contract_1.typeCompatibilityTest(function () { return Type2; });
        describe('that is isomorphic to another type', function () {
            it('should result in two compatible types', function () {
                new Type2(new Type1({ foo: "bar" }));
                chai_1.expect(function () { return new Type2(new Type1({ foo: "bar" })); }).not.to.report({ level: /warn|error|fatal/ });
            });
        });
        it('should allow defining types with primitive fields', function () {
            var primitives = mutable.define('primitives', {
                spec: function () { return ({
                    name: mutable.String.withDefault('leon'),
                    child1: mutable.String,
                    child2: mutable.String
                }); }
            });
            chai_1.expect(new primitives().name).to.equal('leon');
        });
        it('should allow defining types with custom fields', function () {
            var primitives = mutable.define('primitives', {
                spec: function () { return ({
                    name: mutable.String.withDefault('leon'),
                    child1: mutable.String,
                    child2: mutable.String
                }); }
            });
            var composite = mutable.define('composite', {
                spec: function () { return ({
                    child: primitives
                }); }
            });
            chai_1.expect(new composite().child.name).to.equal('leon');
        });
        it('should report error if field type is not valid', function () {
            chai_1.expect(function () {
                mutable.define('invalid', {
                    spec: function () { return ({
                        zagzag: {}
                    }); }
                });
            }).to.report(reports_1.ERROR_IN_FIELD_TYPE('invalid.zagzag'));
        });
        it('should report error if field type is missing', function () {
            chai_1.expect(function () {
                mutable.define('invalid', {
                    spec: function () { return ({
                        zagzag: null
                    }); }
                });
            }).to.report(reports_1.ERROR_IN_FIELD_TYPE('invalid.zagzag'));
        });
        it('should report error for reserved keys', function () {
            chai_1.expect(function () {
                mutable.define('invalid', {
                    spec: function () { return ({
                        $asReadOnly: mutable.String
                    }); }
                });
            }).to.report(reports_1.ERROR_RESERVED_FIELD('invalid.$asReadOnly'));
        });
        describe('type with inheritance', function () {
            var StringList = mutable.List.of(mutable.String);
            var TypeWithTitles;
            var TypeWithInheritance;
            before('define types', function () {
                TypeWithTitles = mutable.define('TypeWithTitles', {
                    spec: function () { return ({
                        titles: StringList
                    }); }
                });
                TypeWithInheritance = mutable.define('TypeWithInheritance', {
                    spec: function () { return ({
                        subTitles: StringList
                    }); }
                }, TypeWithTitles);
            });
            it('should throw error if fields intersect', function () {
                chai_1.expect(function () {
                    mutable.define('TypeWithBrokenInheritance', {
                        spec: function () { return ({
                            titles: StringList
                        }); }
                    }, TypeWithTitles);
                }).to.throw(reports_1.ERROR_OVERRIDE_FIELD('TypeWithBrokenInheritance.titles', 'TypeWithTitles'));
            });
            it('spec should include all fields', function () {
                chai_1.expect(TypeWithInheritance._spec).to.eql({
                    titles: StringList,
                    subTitles: StringList
                });
            });
            it('should include default values for all fields', function () {
                chai_1.expect(TypeWithInheritance.defaults()).to.eql({
                    titles: [],
                    subTitles: []
                });
            });
            it('should include getters setters for all fields', function () {
                var dataItem = new TypeWithInheritance();
                chai_1.expect(dataItem.titles.length).to.equal(0);
                dataItem.titles.push('cell0');
                chai_1.expect(dataItem.titles.at(0)).to.equal('cell0');
                chai_1.expect(dataItem.subTitles.length).to.equal(0);
                dataItem.subTitles.push('cell0');
                chai_1.expect(dataItem.subTitles.at(0)).to.equal('cell0');
            });
            it('should be dirtified when any field from super type is changed', function () {
                var dataItem = new TypeWithInheritance();
                var log = test_drivers_1.getMobxLogOf(function () { return dataItem.titles.push('something'); }, dataItem.titles.__value__);
                chai_1.expect(log).not.to.be.empty;
            });
            it('should be dirtified when any field from type definition is changed', function () {
                var dataItem = new TypeWithInheritance();
                var log = test_drivers_1.getMobxLogOf(function () { return dataItem.subTitles.push('something'); }, dataItem.subTitles.__value__);
                chai_1.expect(log).not.to.be.empty;
            });
        });
        describe('type with generic field', function () {
            it('should throw error if field doesnt include generics info', function () {
                chai_1.expect(function () {
                    mutable.define('invalid', {
                        spec: function () { return ({
                            zagzag: mutable.List
                        }); }
                    });
                }).to.report(reports_1.ERROR_MISSING_GENERICS("invalid.zagzag"));
            });
            it('should throw error if field subtypes are invalid', function () {
                chai_1.expect(function () {
                    mutable.define('invalid', {
                        spec: function () { return ({
                            zagzag: mutable.List.of(mutable.String, function () { })
                        }); }
                    });
                }).to.report(reports_1.ERROR_IN_FIELD_TYPE("invalid.zagzag<string|" + reports_1.arrow + "subtype>"));
            });
            it('should throw error if field subtypes dont include generics info', function () {
                chai_1.expect(function () {
                    mutable.define('invalid', {
                        spec: function () { return ({
                            zagzag: mutable.List.of(mutable.List)
                        }); }
                    });
                }).to.report(reports_1.ERROR_MISSING_GENERICS("invalid.zagzag<" + reports_1.arrow + "List>"));
            });
            it('should throw error if field subtypes have invalid generics info', function () {
                chai_1.expect(function () {
                    mutable.define('invalid', {
                        spec: function () { return ({
                            zagzag: mutable.List.of(mutable.List.of(function () { }))
                        }); }
                    });
                }).to.report(reports_1.ERROR_IN_FIELD_TYPE("invalid.zagzag<" + reports_1.arrow + "List>"));
            });
            it('should allow fields of the same type', function () {
                var NodeType = mutable.define('Node', {
                    spec: function (Node) { return ({
                        children: mutable.List.of(Node),
                        parent: Node.nullable()
                    }); }
                });
                var node = new NodeType();
                chai_1.expect(node.toJSON()).to.eql({ children: [], parent: null });
                node.parent = new NodeType();
                chai_1.expect(node.toJSON()).to.eql({ children: [], parent: { children: [], parent: null } });
                node.children.push(new NodeType());
                chai_1.expect(node.toJSON()).to.eql({ children: [{ children: [], parent: null }], parent: { children: [], parent: null } });
            });
            it.skip('report circular default data', function () { });
        });
    }); //Type definition error: "invalid.zagzag:List<string|⚠subtype⚠>" must be a primitive type or extend core3.Type
    describe('type with default value', function () {
        type_compatibility_contract_1.typeCompatibilityTest(function () { return Type1.withDefault({ foo: 'im special!' }); });
        it('should clone the previous type definition', function () {
            var originalType = mutable.String;
            originalType.options = {};
            var customDefaultType = originalType.withDefault('im special!');
            chai_1.expect(customDefaultType).not.to.equal(originalType);
            chai_1.expect(customDefaultType.options).not.to.equal(originalType.options);
        });
    });
    describe('nullable type', function () {
        it('should clone the previous type definition and options', function () {
            var originalType = mutable.String;
            originalType.options = { randomConfig: { someOption: true } };
            var customDefaultType = originalType.nullable();
            chai_1.expect(customDefaultType).not.to.equal(originalType);
            chai_1.expect(customDefaultType.options).not.to.equal(originalType.options);
            chai_1.expect(customDefaultType.options).to.eql({
                randomConfig: { someOption: true },
                nullable: true
            });
        });
    });
    describe("collection", function () {
        var UserType, AddressType;
        before('define helper types', function () {
            UserType = mutable.define('User', {
                spec: function () { return ({
                    name: mutable.String.withDefault(''),
                    age: mutable.Number.withDefault(10)
                }); }
            });
            AddressType = mutable.define('Address', {
                spec: function () { return ({
                    address: mutable.String.withDefault(''),
                    code: mutable.Number.withDefault(10)
                }); }
            });
        });
        describe("a List type", function () {
            it('as a nullable field should not crash if supplied null as default', function () {
                chai_1.expect(function () {
                    return mutable.define('WithList', {
                        spec: function () { return ({
                            nullList: mutable.List.of(mutable.String).nullable().withDefault(null)
                        }); }
                    });
                }).not.to.throw();
            });
            describe("with no sub-types", function () {
                it('should report error when instantiating', function () {
                    var inValidArrType = mutable.List;
                    chai_1.expect(function () { return new inValidArrType(); }).to.report(new testDrivers_1.Report('error', 'mutable.List', 'List constructor: Untyped Lists are not supported please state type of list item in the format core3.List<string>'));
                });
            });
            describe('with complex element sub-type', function () {
                type_compatibility_contract_1.typeCompatibilityTest(function typeFactory() {
                    return mutable.List.of(UserType);
                });
                describe("instantiation", function () {
                    it('should keep mu objects passed to it that fit its subtypes', function () {
                        var newUser = new UserType();
                        var newAddress = new AddressType();
                        var mixedList = mutable.List.of(generic_types_1.either(UserType, AddressType)).create([newUser, newAddress]);
                        chai_1.expect(mixedList.at(0)).to.eql(newUser);
                        chai_1.expect(mixedList.at(1)).to.eql(newAddress);
                    });
                    it('single subtype List should allow setting data with json, ', function () {
                        var mixedList = mutable.List.of(AddressType).create([{ address: 'gaga' }]);
                        chai_1.expect(mixedList.at(0)).to.be.instanceOf(AddressType);
                        chai_1.expect(mixedList.at(0).code).to.be.eql(10);
                        chai_1.expect(mixedList.at(0).address).to.be.eql('gaga');
                    });
                    it('a multi subtype List should default to first object based types for json', function () {
                        var mixedList = mutable.List.of(generic_types_1.either(AddressType, UserType)).create([{}]);
                        chai_1.expect(mixedList.at(0)).to.be.instanceOf(AddressType);
                    });
                    it('a multi subtype List should detect primitives', function () {
                        var mixedList = mutable.List.of(generic_types_1.either(AddressType, UserType, mutable.String)).create(['gaga']);
                        chai_1.expect(mixedList.at(0)).to.be.eql('gaga');
                    });
                    it('a multi subtype List should use _type field to detect which subtype to use', function () {
                        var mixedList = mutable.List.of(generic_types_1.either(AddressType, UserType, mutable.String)).create([{ _type: 'User' }]);
                        chai_1.expect(mixedList.at(0)).to.be.instanceOf(UserType);
                    });
                    it('should report error when unallowed primitive is added', function () {
                        var ListCls = mutable.List.of(AddressType);
                        chai_1.expect(function () { ListCls.create(['gaga']); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_LIST_CONSTRUCTOR('List<Address>[0]', '<Address>', 'string'));
                        ListCls = mutable.List.of(mutable.Number);
                        chai_1.expect(function () { ListCls.create(['gaga']); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_LIST_CONSTRUCTOR('List<number>[0]', '<number>', 'string'));
                    });
                    it('should report error when object is added an no object types allowed', function () {
                        var ListCls = mutable.List.of(mutable.String);
                        chai_1.expect(function () { ListCls.create([{}]); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_LIST_CONSTRUCTOR('List<string>[0]', '<string>', 'object'));
                    });
                    it('should report error when unallowed mu is added', function () {
                        var ListCls = mutable.List.of(UserType);
                        chai_1.expect(function () { ListCls.create([new AddressType()]); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_LIST_CONSTRUCTOR('List<User>[0]', '<User>', 'Address'));
                    });
                    it('should report error when json with unallowed _type added', function () {
                        var ListCls = mutable.List.of(UserType);
                        chai_1.expect(function () { ListCls.create([{ _type: 'Address' }]); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_LIST_CONSTRUCTOR('List<User>[0]', '<User>', 'object with _type Address'));
                    });
                });
            });
            describe('with union element sub-type', function () {
                type_compatibility_contract_1.typeCompatibilityTest(function typeFactory() {
                    return mutable.List.of(generic_types_1.either(UserType, AddressType));
                });
            });
            describe("with default values", function () {
                type_compatibility_contract_1.typeCompatibilityTest(function () { return mutable.List.of(mutable.String).withDefault(['im special!']); });
                var list, TestType, testType, GroupType;
                before(function () {
                    GroupType = mutable.define('GroupType', {
                        spec: function () {
                            return {
                                title: mutable.String,
                                users: mutable.List.of(UserType)
                            };
                        }
                    });
                });
                before("instantiate with create", function () {
                    list = mutable.List.of(mutable.String).create(["Beyonce", "Rihanna", "Britney", "Christina"]);
                });
                before("define a List type with default", function () {
                    TestType = mutable.define('TestType', {
                        spec: function () { return ({
                            names: mutable.List.of(mutable.String).withDefault(["Beyonce", "Rihanna", "Britney", "Christina"])
                        }); }
                    });
                });
                before("instantiate a type with default List", function () {
                    testType = new TestType();
                });
                it("should have correct initial values in instances", function () {
                    chai_1.expect(list.length).to.equal(4);
                    chai_1.expect(list.at(0)).to.equal("Beyonce");
                    chai_1.expect(list.at(1)).to.equal("Rihanna");
                    chai_1.expect(list.at(2)).to.equal("Britney");
                    chai_1.expect(list.at(3)).to.equal("Christina");
                });
                it("should have correct initial values in withDefaults", function () {
                    chai_1.expect(testType.names.length).to.equal(4);
                    chai_1.expect(testType.names.at(0)).to.equal("Beyonce");
                    chai_1.expect(testType.names.at(1)).to.equal("Rihanna");
                    chai_1.expect(testType.names.at(2)).to.equal("Britney");
                    chai_1.expect(testType.names.at(3)).to.equal("Christina");
                });
                it('Should accept mu.Object as default value', function () {
                    var defaultGroupData = new GroupType({
                        title: 'Title',
                        users: [
                            { 'name': 'tom', 'age': 25 },
                            { 'name': 'omri', 'age': 35 }
                        ]
                    });
                    var NewType = GroupType.withDefault(defaultGroupData);
                    var groupData = new NewType();
                    chai_1.expect(groupData.users.at(0).name).to.equal('tom');
                    chai_1.expect(groupData.users.at(0).age).to.equal(25);
                    chai_1.expect(groupData.users.at(1).name).to.equal('omri');
                    chai_1.expect(groupData.users.at(1).age).to.equal(35);
                });
            });
        });
    });
});
//# sourceMappingURL=define-type.spec.js.map