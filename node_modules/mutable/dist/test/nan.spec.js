"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mu = require("../src");
var chai_1 = require("chai");
var lodash_1 = require("lodash");
var sinon = require("sinon");
describe("setting NaN value", function () {
    var currValue, setter;
    beforeEach('set up object', function () {
        setter = sinon.spy();
    });
    describe("in a user type", function () {
        var Container, instance;
        before('set up type', function () {
            Container = mu.define('Container', { spec: function () { return ({ num: mu.Number }); } });
        });
        beforeEach('set up object', function () {
            instance = new Container();
            instance.__value__ = {
                get num() {
                    return currValue;
                },
                set num(n) {
                    setter(n);
                }
            };
        });
        describe("set value to NaN if pre-existing normal number value", function () {
            beforeEach('set pre-existing value to 6', function () {
                currValue = 6;
            });
            it('property setter', function () {
                instance.num = NaN;
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
            it('setValue', function () {
                instance.setValue({ num: NaN });
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
            it('setValueDeep', function () {
                instance.setValueDeep({ num: NaN });
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
        });
        describe("do nothing if pre-existing NaN value", function () {
            beforeEach('set pre-existing value to NaN', function () {
                currValue = NaN;
            });
            it('property setter', function () {
                instance.num = NaN;
                chai_1.expect(setter).to.have.not.been.called;
            });
            it('setValue', function () {
                instance.setValue({ num: NaN });
                chai_1.expect(setter).to.have.not.been.called;
            });
            it('setValueDeep', function () {
                instance.setValueDeep({ num: NaN });
                chai_1.expect(setter).to.have.not.been.called;
            });
        });
    });
    describe("in a list", function () {
        var Container, instance;
        before('set up type', function () {
            Container = mu.List.of(mu.Number);
        });
        beforeEach('set up object', function () {
            instance = new Container();
            instance.__value__ = {
                get '0'() {
                    return currValue[0];
                },
                set '0'(n) { },
                get '1'() {
                    return currValue[1];
                },
                set '1'(n) {
                    setter(n);
                },
                get '2'() {
                    return currValue[2];
                },
                set '2'(n) { }
            };
        });
        describe("set value to NaN if pre-existing normal number value", function () {
            beforeEach('set pre-existing value to 1', function () {
                currValue = [1, 1, 1];
            });
            it('property setter', function () {
                instance.set(1, NaN);
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
            it('setValue', function () {
                instance.setValue([1, NaN, 1]);
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
            it('setValueDeep', function () {
                instance.setValueDeep([1, NaN, 1]);
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
        });
        describe("do nothing if pre-existing NaN value", function () {
            beforeEach('set pre-existing value to NaN', function () {
                currValue = [1, NaN, 1];
            });
            it('property setter', function () {
                instance.set(1, NaN);
                chai_1.expect(setter).to.have.not.been.called;
            });
            it('setValue', function () {
                instance.setValue([1, NaN, 1]);
                chai_1.expect(setter).to.have.not.been.called;
            });
            it('setValueDeep', function () {
                instance.setValueDeep([1, NaN, 1]);
                chai_1.expect(setter).to.have.not.been.called;
            });
        });
    });
    describe("in a map", function () {
        var Container, instance, otherChangeSpy;
        before('set up type', function () {
            Container = mu.Es5Map.of(mu.Number);
        });
        beforeEach('set up object', function () {
            otherChangeSpy = sinon.spy();
            instance = new Container();
            instance.__value__ = {
                keys: function () {
                    return Object.keys(currValue);
                },
                get: function (key) {
                    return currValue[key];
                },
                set: function (key, val) {
                    if (key == 'bingo') {
                        setter(val);
                    }
                },
                clear: function () {
                    otherChangeSpy();
                },
                merge: function (newValue) {
                    setter(newValue.bingo === undefined ? newValue.get('bingo') : newValue.bingo);
                },
                forEach: function (cb) {
                    lodash_1.forEach(this, cb);
                }
            };
        });
        describe("set value to NaN if pre-existing normal number value", function () {
            beforeEach('set pre-existing value to 1', function () {
                currValue = { bingo: 1 };
            });
            it('property setter', function () {
                instance.set('bingo', NaN);
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
            it('setValue', function () {
                instance.setValue({ bingo: NaN });
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
            it('setValueDeep', function () {
                instance.setValueDeep({ bingo: NaN });
                chai_1.expect(setter).to.have.been.calledWith(NaN);
            });
        });
        describe("do nothing if pre-existing NaN value", function () {
            beforeEach('set pre-existing value to NaN', function () {
                currValue = { bingo: NaN };
            });
            it('property setter', function () {
                instance.set('bingo', NaN);
                chai_1.expect(setter).to.have.not.been.called;
            });
            it('setValue', function () {
                instance.setValue({ bingo: NaN });
                chai_1.expect(setter).to.have.not.been.called;
            });
            it('setValueDeep', function () {
                instance.setValueDeep({ bingo: NaN });
                chai_1.expect(setter).to.have.not.been.called;
            });
        });
    });
});
//# sourceMappingURL=nan.spec.js.map