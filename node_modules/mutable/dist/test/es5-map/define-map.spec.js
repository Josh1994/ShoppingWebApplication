"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testDrivers_1 = require("escalate/dist/test-kit/testDrivers");
var type_compatibility_contract_1 = require("../type-compatibility.contract");
var mu = require("../../src");
var reports_1 = require("../../test-kit/test-drivers/reports");
var generic_types_1 = require("../../src/core/generic-types");
describe("defining", function () {
    describe("a es5map type", function () {
        var UserType, AddressType;
        before('define helper types', function () {
            UserType = mu.define('User', {
                spec: function () { return ({
                    name: mu.String.withDefault(''),
                    age: mu.Number.withDefault(10)
                }); }
            });
            AddressType = mu.define('Address', {
                spec: function () { return ({
                    address: mu.String.withDefault(''),
                    code: mu.Number.withDefault(10)
                }); }
            });
        });
        describe('as es5map<boolean> field', function () {
            it('should crash if supplied mu type as map default', function () {
                chai_1.expect(function () { return mu.define('WithMapUser', {
                    spec: function () { return ({
                        map: mu.Es5Map.of(mu.Boolean).nullable().withDefault(new mu.Es5Map.of(mu.Boolean)())
                    }); }
                }); }).to.throw();
            });
            it('should not crash if supplied empty object as map default', function () {
                chai_1.expect(function () { return mu.define('WithMapUser', {
                    spec: function () { return ({
                        map: mu.Es5Map.of(mu.Boolean).nullable().withDefault({})
                    }); }
                }); }).not.to.throw();
            });
            describe('allowPlainVal', function () {
                it('should accept empty object', function () {
                    var allowPlainVal = mu.Es5Map.of(mu.Boolean).nullable().allowPlainVal({});
                    chai_1.expect(allowPlainVal).to.be.true;
                });
                it('should accept object with _type', function () {
                    var allowPlainVal = mu.Es5Map.of(mu.Boolean).nullable().allowPlainVal({ _type: 'string-value' });
                    chai_1.expect(allowPlainVal).to.be.true;
                });
                it('should accept object with boolean value', function () {
                    var allowPlainVal = mu.Es5Map.of(mu.Boolean).nullable().allowPlainVal({ someKey: true });
                    chai_1.expect(allowPlainVal).to.be.true;
                });
                it('should not accept object with mismatched types', function () {
                    var allowPlainVal = mu.Es5Map.of(mu.Boolean).nullable().allowPlainVal({ someKey: 'string-value' });
                    chai_1.expect(allowPlainVal).to.be.false;
                });
            });
        });
        describe('with default value', function () {
            type_compatibility_contract_1.typeCompatibilityTest(function () { return mu.Es5Map.of(mu.String).withDefault({ lookAtMe: 'im special!' }); });
        });
        describe("with missing sub-types", function () {
            it('should report error when instantiating vanilla Map', function () {
                var invalidMapType = mu.Es5Map;
                chai_1.expect(function () { return new invalidMapType(); }).to.report(new testDrivers_1.Report('error', 'mutable.Es5Map', "Es5Map constructor: \"\u27A0Es5Map\" Untyped Maps are not supported please state types of key and value in the format core3.Es5Map<SomeType>"));
            });
            it('should report error when defining Map with zero types', function () {
                chai_1.expect(function () { var map = mu.Es5Map.of(); new map(); }).to.report(new testDrivers_1.Report('error', 'mutable.Es5Map', "Es5Map constructor: \"\u27A0Es5Map\" Missing types for map. Use Es5Map<SomeType>"));
            });
            it('should report error when defining Map with invalid subtype', function () {
                chai_1.expect(function () { var map = mu.Es5Map.of(mu.List); new map(); }).to.report(new testDrivers_1.Report('error', 'mutable.Es5Map', 'Es5Map constructor: "Es5Map<âž List>" Untyped Lists are not supported please state type of list item in the format core3.List<string>'));
            });
        });
        describe('with complex value sub-type', function () {
            function typeFactory() {
                return mu.Es5Map.of(AddressType);
            }
            type_compatibility_contract_1.typeCompatibilityTest(typeFactory);
            describe("instantiation", function () {
                it('should allow setting data with json, ', function () {
                    var map = typeFactory().create({ 'foo': { address: 'gaga' } });
                    chai_1.expect(map.get('foo')).to.be.instanceOf(AddressType);
                    chai_1.expect(map.get('foo').code).to.equal(10);
                    chai_1.expect(map.get('foo').address).to.equal('gaga');
                });
            });
            it('should report error when null key is added', function () {
                chai_1.expect(function () { return typeFactory().create([[null, 'gaga']]); }).to.report(reports_1.ERROR_KEY_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<string>', 'null', 'Es5Map'));
            });
            it('should report error when null key is added', function () {
                chai_1.expect(function () { return typeFactory().create([[5, null]]); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<Address>', 'null', 'Es5Map'));
            });
            it('should report error when unallowed primitive key is added', function () {
                chai_1.expect(function () { return typeFactory().create([[5, 'gaga']]); }).to.report(reports_1.ERROR_KEY_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<string>', 'number', 'Es5Map'));
            });
            it('should report error when unallowed primitive value is added', function () {
                chai_1.expect(function () { return typeFactory().create([['baga', 'gaga']]); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<Address>', 'string', 'Es5Map'));
            });
            it('should report error when unallowed object key is added', function () {
                chai_1.expect(function () { return typeFactory().create([[{}, new AddressType()]]); }).to.report(reports_1.ERROR_KEY_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<string>', 'object', 'Es5Map'));
            });
            it('should report error when when json value with unallowed _type is added', function () {
                chai_1.expect(function () { return typeFactory().create([['baga', { _type: 'User' }]]); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<Address>', 'object with _type User', 'Es5Map'));
            });
            it('should report error when unallowed mu key is added', function () {
                chai_1.expect(function () { return typeFactory().create([[new UserType(), new AddressType()]]); }).to.report(reports_1.ERROR_KEY_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<string>', 'User', 'Es5Map'));
            });
            it('should report error when unallowed mu value is added', function () {
                chai_1.expect(function () { return typeFactory().create([['gaga', new UserType()]]); }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_MAP_CONSTRUCTOR('Es5Map<Address>', '<Address>', 'User', 'Es5Map'));
            });
        });
        describe('with union value sub-type', function () {
            function typeFactory() {
                return mu.Es5Map.of(generic_types_1.either(UserType, AddressType, mu.String));
            }
            type_compatibility_contract_1.typeCompatibilityTest(typeFactory);
            describe("instantiation", function () {
                var newUser, newUser2, newAddress;
                beforeEach(function () {
                    newUser = new UserType();
                    newUser2 = new UserType();
                    newAddress = new AddressType();
                });
                it('should keep mu objects passed to it that fit its subtypes', function () {
                    var mixedMap = typeFactory().create([['newUser', newUser], ['newUser2', newAddress]]);
                    chai_1.expect(mixedMap.get('newUser')).to.equal(newUser);
                    chai_1.expect(mixedMap.get('newUser2')).to.equal(newAddress);
                });
                it('should allow setting data with json and should default to first type, ', function () {
                    var map = typeFactory().create([['newUser', { someKey: 'gaga' }]]);
                    chai_1.expect(map.get('newUser')).to.be.instanceOf(UserType);
                });
                it('should use _type field to detect which subtype to use when setting data with json, ', function () {
                    var map = typeFactory().create([['newUser', { _type: AddressType.id, address: 'gaga' }]]);
                    chai_1.expect(map.get('newUser')).to.be.instanceOf(AddressType);
                    chai_1.expect(map.get('newUser').address).to.equal('gaga');
                });
                it('should NOT validate the _type field on JSON value on create() ', function () {
                    var StringToNumber = mu.Es5Map.of(mu.Number);
                    var json = new StringToNumber({ "key1": 5 }).toJSON(true, true);
                    chai_1.expect(json._type).to.be.ok;
                    var map;
                    chai_1.expect(function () {
                        map = StringToNumber.create(json);
                    }).to.not.throw();
                    chai_1.expect(map.get('key1')).to.equal(5);
                });
                it('should NOT validate the _type field on JSON value on setValue() ', function () {
                    var StringToNumber = mu.Es5Map.of(mu.Number);
                    var json = new StringToNumber({ "key1": 5 }).toJSON(true, true);
                    chai_1.expect(json._type).to.be.ok;
                    var map = new StringToNumber();
                    chai_1.expect(function () {
                        map.setValue(json);
                    }).to.not.throw();
                    chai_1.expect(map.get('key1')).to.equal(5);
                });
                it('should NOT validate the _type field on JSON value on setValueDeep() ', function () {
                    var StringToNumber = mu.Es5Map.of(mu.Number);
                    var json = new StringToNumber({ "key1": 5 }).toJSON(true, true);
                    chai_1.expect(json._type).to.be.ok;
                    var map = new StringToNumber();
                    chai_1.expect(function () {
                        map.setValueDeep(json);
                    }).to.not.throw();
                    chai_1.expect(map.get('key1')).to.equal(5);
                });
                it('should detect primitives', function () {
                    var mixedMap = typeFactory().create([['newUser', 'gaga']]);
                    chai_1.expect(mixedMap.get('newUser')).to.be.equal('gaga');
                });
            });
        });
        describe('with value type that is a union of maps', function () {
            function typeFactory() {
                return mu.Es5Map.of(generic_types_1.either(mu.Es5Map.of(mu.String), mu.Es5Map.of(mu.Number)));
            }
            type_compatibility_contract_1.typeCompatibilityTest(typeFactory);
            describe("instantiation", function () {
                it('should allow setting data with array', function () {
                    var mixedMap = typeFactory().create([['foo', [['bar', 'baz']]], ['foo2', [['bar2', 2]]]]);
                    chai_1.expect(mixedMap.get('foo').get('bar')).to.equal('baz');
                    chai_1.expect(mixedMap.get('foo2').get('bar2')).to.equal(2);
                });
                it('should allow setting data with json', function () {
                    var mixedMap = typeFactory().create({ foo: { bar: 'baz' }, foo2: { bar2: 2 } });
                    chai_1.expect(mixedMap.get('foo').get('bar')).to.equal('baz');
                    chai_1.expect(mixedMap.get('foo2').get('bar2')).to.equal(2);
                });
            });
        });
    });
});
//# sourceMappingURL=define-map.spec.js.map