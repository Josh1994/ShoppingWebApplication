"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var test_drivers_1 = require("../test-kit/test-drivers");
var mu = require("../src");
var generic_types_1 = require("../src/core/generic-types");
var reports_1 = require("../test-kit/test-drivers/reports");
var type_compatibility_contract_1 = require("./type-compatibility.contract");
var TypeA = test_drivers_1.aDataTypeWithSpec({ bar: mu.String }, 'TypeA');
var TypeB = test_drivers_1.aDataTypeWithSpec({ bar: mu.Number }, 'TypeB');
describe('a type with union type field', function () {
    function defineType() {
        return test_drivers_1.aDataTypeWithSpec({ foo: generic_types_1.either(TypeA, TypeB, mu.String, mu.Number) }, 'Generic');
    }
    function defineNullableType() {
        return test_drivers_1.aDataTypeWithSpec({ foo: generic_types_1.either(mu.String, TypeA, TypeB).nullable(true) }, 'GenericNullable');
    }
    it('should not throw on definition', function () {
        chai_1.expect(defineType).to.not.throw();
    });
    type_compatibility_contract_1.typeCompatibilityTest(defineType);
    describe('constructor', function () {
        it('should accept either type', function () {
            var Type = defineType();
            chai_1.expect(new Type({ foo: 'bar' }).foo).to.eql('bar');
            chai_1.expect(new Type({ foo: 2 }).foo).to.eql(2);
            var foo = new TypeA();
            chai_1.expect(new Type({ foo: foo }).foo).to.eql(foo);
        });
        it('should not accept unknown type', function () {
            var Type = defineType();
            chai_1.expect(function () {
                return new Type({ foo: new Type() });
            }).to.report(reports_1.ERROR_FIELD_MISMATCH_IN_CONSTRUCTOR('Generic.foo', 'TypeA|TypeB|string|number', 'Generic'));
        });
        it('should accept null if allowed', function () {
            var Type = defineNullableType();
            chai_1.expect(new Type({ foo: null }).foo).to.equal(null);
        });
    });
    describe('setter', function () {
        it('should accept either type', function () {
            var Type = defineType();
            var instance = new Type();
            instance.foo = 'bar';
            chai_1.expect(instance.foo).to.equal('bar');
            instance.foo = 2;
            chai_1.expect(instance.foo).to.equal(2);
            var foo = new TypeA();
            instance.foo = foo;
            chai_1.expect(instance.foo).to.equal(foo);
        });
        /**
         *  simulation of
         *  https://github.com/wix/mutable/issues/85
         *  The bug only happens when there is a List field in the type of the complex value, as List.validate does not accept List instances.
         */
        it('should accept type (regression - list field in the type)', function () {
            var TypeC = test_drivers_1.aDataTypeWithSpec({ bar: mu.List.of(mu.String) }, 'TypeC');
            var Type = mu.define('Type', {
                spec: function () { return ({
                    foo: generic_types_1.either(TypeA, TypeC)
                }); }
            });
            var instance = new Type();
            var foo = new TypeC(['a', 'b']);
            instance.foo = foo;
            chai_1.expect(instance.foo).to.equal(foo);
        });
        it('should not accept unknown type', function () {
            var Type = defineType();
            var instance = new Type();
            chai_1.expect(function () {
                instance.foo = new Type();
            }).to.report(reports_1.ERROR_IN_SET('Generic.foo', 'TypeA|TypeB|string|number', 'Generic'));
        });
    });
    describe('get', function () {
        it('should work with primitives in readonly', function () {
            var Type = defineType();
            var instance = new Type({ foo: 'bar' });
            chai_1.expect(instance.foo).to.equal('bar');
            chai_1.expect(instance.$asReadOnly().foo).to.equal('bar');
        });
    });
    describe('setValue', function () {
        it('should accept either type of mu', function () {
            var Type = defineType();
            var instance = new Type();
            instance.setValue({ foo: 'bar' });
            chai_1.expect(instance.foo).to.eql('bar');
            instance.setValue({ foo: 2 });
            chai_1.expect(instance.foo).to.eql(2);
            var val = new TypeA();
            instance.setValue({ foo: val });
            chai_1.expect(instance.foo).to.equal(val);
            val = new TypeB();
            instance.setValue({ foo: val });
            chai_1.expect(instance.foo).to.equal(val);
        });
        it('should accept either form of JSON', function () {
            var Type = defineType();
            var instance = new Type();
            var val = new TypeA().toJSON();
            instance.setValue({ foo: val });
            chai_1.expect(instance.foo.toJSON()).to.eql(val);
            val = new TypeB().toJSON();
            instance.setValue({ foo: val });
            chai_1.expect(instance.foo.toJSON()).to.eql(val);
        });
        it("should accept null if nullable", function () {
            var Type = defineNullableType();
            var instance = new Type({
                foo: 'Monkey'
            });
            chai_1.expect(function () { return instance.setValue({ foo: null }); }).to.not.throw();
        });
        it("shouldn't crap its pants", function () {
            var Type = defineType();
            var instance = new Type({
                foo: 'Monkey'
            });
            chai_1.expect(function () { return instance.toJSON(); }).to.not.throw();
        });
    });
});
//# sourceMappingURL=union.spec.js.map