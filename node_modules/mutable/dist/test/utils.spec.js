"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var sinon = require("sinon");
var chai_1 = require("chai");
var utils_1 = require("../src/utils");
var validation_1 = require("../src/core/validation");
describe('utils', function () {
    describe("cloneType", function () {
        it("should merge origin type options with constructor options", function () {
            var spy = sinon.spy();
            var MockType = (function () {
                function MockType() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    spy.apply(void 0, args);
                }
                return MockType;
            }());
            MockType.options = { a: true };
            var CloneType = utils_1.cloneType('CloneType', MockType);
            new CloneType("value", { b: false });
            chai_1.expect(spy).to.have.been.calledWith("value", { a: true, b: false });
        });
        it("two inherited classes should still be isAssignableFrom", function () {
            var MockType = (function () {
                function MockType() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    spy.apply(void 0, args);
                }
                return MockType;
            }());
            MockType.options = { a: true };
            var CloneType1 = utils_1.cloneType('CloneType1', MockType);
            var CloneType2 = utils_1.cloneType('CloneType2', MockType);
            chai_1.expect(validation_1.isAssignableFrom(CloneType1, CloneType2)).to.eql(true);
        });
    });
});
//# sourceMappingURL=utils.spec.js.map