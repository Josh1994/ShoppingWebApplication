(function (global, factory) {
	if (typeof define === "function" && define.amd) {
		define(['exports', '../../src/index'], factory);
	} else if (typeof exports !== "undefined") {
		factory(exports, require('../../src/index'));
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, global.index);
		global.index = mod.exports;
	}
})(this, function (exports, _index) {
	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Report = undefined;
	exports.listen = listen;

	var escalate = _interopRequireWildcard(_index);

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};

			if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}

			newObj.default = obj;
			return newObj;
		}
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];
				descriptor.enumerable = descriptor.enumerable || false;
				descriptor.configurable = true;
				if ("value" in descriptor) descriptor.writable = true;
				Object.defineProperty(target, descriptor.key, descriptor);
			}
		}

		return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);
			if (staticProps) defineProperties(Constructor, staticProps);
			return Constructor;
		};
	}();

	function listen(actions) {
		var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (ctx) {
			return ctx != 'escalate';
		};

		return new Recorder().record(actions, filter).reports;
	}

	var Recorder = function () {
		function Recorder() {
			_classCallCheck(this, Recorder);

			this.reports = [];
		}

		_createClass(Recorder, [{
			key: 'record',
			value: function record(actions) {
				var _this = this;

				var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _.constant(true);

				// save old config
				var oldConfig = escalate.config();
				try {
					// spy on escalate
					escalate.config({
						loggerStrategy: function loggerStrategy(ctx) {
							return filter(ctx) ? {
								debug: spyReporter(_this.reports, 'debug', ctx),
								info: spyReporter(_this.reports, 'info', ctx),
								warn: spyReporter(_this.reports, 'warn', ctx),
								error: spyReporter(_this.reports, 'error', ctx)
							} : oldConfig.loggerStrategy(ctx);
						},
						panicStrategy: function panicStrategy(ctx) {
							return filter(ctx) ? spyReporter(_this.reports, 'fatal', ctx) : oldConfig.panicStrategy(ctx);
						},
						logThresholdStrategy: function logThresholdStrategy(ctx) {
							return filter(ctx) ? 'debug' : oldConfig.logThresholdStrategy(ctx);
						},
						panicThresholdStrategy: function panicThresholdStrategy(ctx) {
							return filter(ctx) ? 'fatal' : oldConfig.panicThresholdStrategy(ctx);
						}
					});
					// run actions
					actions();
					// restore config
				} finally {
					escalate.config(oldConfig);
				}
				return this;
			}
		}]);

		return Recorder;
	}();

	function spyReporter(reports, level, context) {
		return function () {
			for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
				params[_key] = arguments[_key];
			}

			return reports.push(new Report(level, context, params));
		};
	}

	var Report = exports.Report = function Report(level, context, params) {
		_classCallCheck(this, Report);

		this.level = level;
		this.context = context;
		this.params = params;
	};
});
//# sourceMappingURL=index.js.map